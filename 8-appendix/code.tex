\subsection{\textit{nETL}}
\label{netl-trans-fitler}
\begin{minted}{javascript}
'use strict';
/**
 * Configuration looks like this:
 * filterOn: {"key1"; [<list of allowed values>], "key2": [...], ...}
 * filtering can either be done on objects or arrays since
 * arrays 'keys' are treated as indexes
 *
 * Configuration example:
 * {
 *     "Name": "FILTER",
 *     "filterOn": {
 *         "field1": [<list of allowed values>],
 *         "field2": [<list of allowed values>],
 *         etc...
 *     },
 *     "afterTaskRunCBs": []
 * }
 */
function FILTER() {
    const t = this;
    const filterOn = t.filterOn;
    function transform(batch) {
        const transformedBatch = [];
        batch.forEach(function(datum) {
            var includeThisObj = true;
            Object.keys(filterOn).forEach(function(key) {
                if (filterOn[key].indexOf(datum[key]) < 0) {
                    includeThisObj = false;
                }
            });
            if (includeThisObj) transformedBatch.push(datum);
        });
        return transformedBatch;
    };
    return {
        transform: transform
    };
};
module.exports = {
    name: 'FILTER',
    exe: FILTER
};
\end{minted}


\label{netl-trans-create-object-field}
\begin{minted}{javascript}
'use strict';
/**
 * Configuration example:
 * {
 *     "Name": "CREATE_OBJ_FIELD",
 *     "newAttributes": [
 *         ["type_", "<someValue>"]
 *     ],
 *     "afterTaskRunCBs": []
 * },
 */
function CREATE_OBJ_FIELD() {
    const t = this;
    function transform(batch) {
        const transformedBatch = JSON.parse(JSON.stringify(batch));
        transformedBatch.forEach(function(datum) {
            if (datum.length == 0) return;
            t.newAttributes.forEach(function(attr) {
                // Throw error if key already exists
                if (datum.hasOwnProperty(attr[0])) {
                    throw new Error("New property not allowed!");
                }
                datum[attr[0]] = attr[1]
            });
        });
        return transformedBatch;
    };
    return {
        transform: transform
    };
};
module.exports = {
    name: 'CREATE_OBJ_FIELD',
    exe: CREATE_OBJ_FIELD
};
\end{minted}










\subsection{SQL Queries}
\label{appendix:sql}

\begin{minted}{sh}
grep -E 'Starting\s.*i3|Index\supdate\sfinished.*i3' couchdb.log
\end{minted}


\begin{minted}{sql}
select
count(E.event_id) c 
from Events E
where exists (
    select 1
    from Grades G
    where G.anonIDnew = E.uct_id
    and (
        G.Course = 'ECO1010F'
        or G.Course = 'ECO1011S'
        or G.Course = 'ACC1006F'
        or G.Course = 'STA1000S'
        or G.Course = 'ECO2003F'
        or G.Course = 'BUS1036F'
        or G.Course = 'ECO2004S'
        or G.Course = 'CML1001F'
        or G.Course = 'MAM1010F'
        or G.Course = 'PSY1004F'
        or G.Course = 'FTX2024S'
        or G.Course = 'ECO2007S'
        or G.Course = 'ACC2011S'
        or G.Course = 'CSC1015F'
        or G.Course = 'PHI2043S'
        or G.Course = 'ACC3023S'
        or G.Course = 'INF2004F'
        or G.Course = 'PSY1005S'
        or G.Course = 'STA2020F'
        or G.Course = 'CML2010S'
        or G.Course = 'CML2001F'
        or G.Course = 'SOC1001F'
        or G.Course = 'ACC2018S'
        or G.Course = 'SOC1005S'
        or G.Course = 'BUS2010F'
        or G.Course = 'ACC2012W'
        or G.Course = 'AXL1100S'
        or G.Course = 'ACC3022H'
        or G.Course = 'ACC3004H'
        or G.Course = 'PHY1012F'
        or G.Course = 'MAM1020F'
        or G.Course = 'PHI2043F'
        or G.Course = 'FTX3045S'
        or G.Course = 'ACC3009W'
        or G.Course = 'MAM1012S'
        or G.Course = 'FTX3044F'
        or G.Course = 'MAM1000W'
        or G.Course = 'POL1004F'
        or G.Course = 'CSC1016S'
        or G.Course = 'ACC4000H'
    )
);
\end{minted}