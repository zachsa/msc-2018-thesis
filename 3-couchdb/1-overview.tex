\subsection{Overview}
The CouchDB database is a 'document' based data-store, meaning that a CouchDB database comprises a series of JSON strings. A brief description of CouchDB's internals is discussed in online documentation \cite{couchguide}: JSON strings are appended to database files that are structured as B+ trees optimized for fast data retrieval from huge databases, that B+ tree implementation incorporates a MVCC (Multi-Version-Concurrency-Control) model, and that disc-writing is done via an 'append-only' approach. Aside from write operations being serialized, MVCC negates the needs for locks that are typically implemented within RDBMSs and are expensive in terms of computer resources. Without locking on read/write operations, CouchDB data stores are infinitely available with the caveat that such available documents may not always be the most recent versions of those documents. CouchDB represents a trade-off of \textit{consistency} for \textit{availability} to facilitate scalability in terms of handling large amounts of data in near-realtime. In this way CouchDB could be considered with reference to the \textit{BASE} model similarly to many other NoSQL databases. \textit{BASE} stands for \textit{Basically Available}, \textit{Soft State}, \textit{Eventual Consistency}. This is in contrast to \textit{ACID} guarantees that older RDMSs guarantee, although CouchDB does guarantee atomic (all or nothing) document writes. Research in 1999 by \cite{cap} introduced the idea of the \textit{CAP} theorem as a trade-off analysis of 3 properties of a data storage system\textit{Consistency}, \textit{Availability}, and \textit{Partition-tolerance} faced with the inevitability of network downtime. Despite populate opinion, all three properties ARE fully achievable without network downtime. From CouchDB 2.0 onwards users can configure the desired level of consistency of document reads, but not document writes.

CouchDB as a document store doesn't, in itself, provide a means of data-querying. Instead it allows for processing of database file(s) via MapReduce to produce separate files (\textit{Views}) that are derived from a single database. These derived sets of data are also structured as B+Trees, as are the initial database files. In other words, A CouchDB database may comprise B+ tree files for storage and separate B+ tree index files for querying. As pointed out in the documentation \cite{couchguide}, CouchDB is effectively a B+tree engine that provides users a means of interacting directly with B+trees via an HTTP API. Via this API a user is able to interact directly with the database B+tree, to which all view files are linked; changes to a database file results in incremental adjustment of the view file via the specified MapReduce functions. So in a sense you donâ€™t 'query' couch. You actually specify a MapReduce task to create a completely separate store of data. And then you can search the B+ tree view files by using the REST API.

\subsection{Entity Models}
Compared to relational models, CouchDB data models need to be represented by JSON structure. This is fairly straightforward for entities that can be easily thought of as 'objects'. JSON allows for nesting 'child' entities as sub-objects as an alternative to foreign key references in relational tables. As such, data is typically grouped differently in JSON documents compared to relational tables: JSON encourages groupings of specific entities, while relational tables encourage grouping entity types. Because JSON is far less structured than relational tables, entities of the same type may be represented differently - i.e. to think of entities as 'rows' of a relational table, each entity is allowed it's own variety of 'columns' in a JSON store. In a relational database this would result in a sparse table where every row has to include the columns of every other row of the same entity type. Such a case would result in massive amounts of wasted storage and inefficient indexing.

\subsection{CouchDB Server API}
CouchDB allows a user to specify several different types of functions that are executed on the server-side Erlang application. These functions need to be specified on a 'Design' document, which is simply a normal JSON document with an attribute "\_id" having a value of "\_design/documentName". There are 6 types of functions that a user can specify and are executed by the CouchDB application on the server: \textit{views}, \textit{shows}, \textit{lists}, \textit{updates}, \textit{filters}, and \textit{validation} checks. A full list of the server API can be seen in the sample design document in \ref{couchdb-design-doc-sample}. Via this API much of the functionality that you typically find in an RDBMS can be implemented in couchDB (albeit in a roundabout way). For example a SQL trigger could be implemented via a CouchDB \textit{update}, a SQL query could be implemented as a \textit{list} function and a \textit{view} index, etc. While the full range of data-interactions available on an RDBMS are available via CouchDB, however, to work with such a different DBMS requires a vastly different mindset when compared to working with a RDBMS since there is very little similarity between these systems.

\subsection{Views}
Views comprise two components - a \textit{Map}-function component and a \textit{Reduce}-function component. The logic of these components can be specified by users as separate \textit{Map} and \textit{Reduce} functions - the contracts of which are shown in the appendix (see \ref{couchdb-mapreduce-contracts}). Such functions can be specified in a variety of languages including JavaScript and are executed via an engine external to the main CouchDB Erlang process. \textit{Map} functions must be specified by a user and are always executed external to the main Erlang process via marshalling between the main Erlang process and the view-calculating engine. \textit{Reduce} functions, however, can either by executed externally to the main Erlang process (as a custom reduce function) or within the main Erlang process via one of three built in functions: \_count, \_sum, and \_stats. These functions are presumably see enough common functionality between different types of queries that it was worthwhile implementing these functions within the main Erlang process, which according to the documentation offers a performance boost since the IO transfer cost between the Erlang process and the view engine (couchjs.exe by default) is negated. Working on a Windows machine the IO cost is apparently exaggerated (see the slack correspondence with Jan Lehnardt in appendix \ref{slack-1-nov}) due to the difference between Unix-based and Windows kernel implementations.

\subsection{MapReduce Implementation}
Unlike in the traditional sense of 'MapReduce', Couch's reduce engine allows for partial groupings of a key via specifying the concept of 'rereduction' in the contract of the reduce function. More accurately, \textit{map} results are stored as B+ indexes within CouchDB including \textit{reduce} results cached on internal nodes (\cite{reduceFunctions} and see appendix \ref{slack-25-oct}) of these indexes. This allows for reduce output of nodes to be re-used and allows for incremental index updates.

As mentioned on the original CouchDB Wiki (no longer maintained, and is being migrated), \textit{map} output is sent the \textit{Reducer} in batches delimited by B+tree boundaries \cite{couchwiki}. Since grouping is done after this step by the \textit{Reducer}, reduce functions must allow for the case that not all values for a key are processed at once or by the same \textit{reduce} function. This allows for dispersed, partial and autonomous view calculation on any CouchDB node.

In terms of how MapReduce is executed in CouchDB, and possibly related to B+tree storage structures as mentioned above, grouping and reducing in CouchDB is handled by a 'master' node for any particular shard. Unlike a traditional implementation of MapReduce where \textit{Map} and \textit{reduce} tasks are executed in parallel, CouchDB spawns a single \textit{couchjs} process per shard (see \ref{slack-1-nov} and \ref{slack-7-nov}) and the map index is calculated sequentially according to a list of database changes as managed by CouchDB (available at the \textit{\_changes} endpoint).

Worth mentioning in the context of couchDB specifically, is the MapReduce engine used. CouchDB ships with an executable "couchjs.exe" - the \textit{javaScript} query-server - coupled with Mozilla's \textit{SpiderMonkey} runtime engine; this query engine is drop-in replaceable, although there is probably no motivation to do so. According to the documentation \cite{builtincouchreduce}, CouchDB has with a couple built-in reduce function - \_sum, \_count, and \_stats that are implemented as functions within the main Erlang process (as distinct from the mapping and reduction being handled by the main process) that perform substantially better than custom reduce functions since custom functions are not optimized and need to be executed externally to main process. This results in an I\/O overheard that is particularly severe on Windows machines (see \ref{slack-1-nov}).

Because of the nature of the \textit{reduce} function contract (allowing for rereduce = true), joins via MapReduce as described by \cite{chandar2010} are simply not possible. A SQL query of the form: \textit{R(a,b)} joined with \textit{S(b,c)} joined with \textit{T(c,d)} (where \textit{R}, \textit{S} and \textit{T} are relations and \textit{a}, \textit{b}, \textit{c}, \textit{d} are attributes) and expressed by the code (SQL Server syntax) below cannot be achieved without prior processing of all or some of the relations, or in the spirit of CouchDB, via multiple interactions with a view.

\begin{minted}{sql}
SELECT
[R].[a],
[T].[d]
FROM [R]
LEFT JOIN [S] on [S].[b] = [R].[b]
LEFT JOIN [T] ON [T].[c] = [S].[c]
\end{minted}

Although conceptually it's possible to produce composite return structures via CouchDB's Map and Reduce functions, as mentioned in in \cite{reduceFunctions}, this is a misuse of CouchDB's query engine. Reduce functions in CouchDB views are specifically optimized to allow incremental index alterations (i.e. incrementally altering the view index in response to a document added to the database) \cite{reduceFunctions}. As such, reduce functions in CouchDB are specifically aimed at aggregating output of Map functions.

This is unlike other implementations of MapReduce, for example for Hadoop, where MapReduce tasks may comprise 'pipelines' of multiple map and reduce phases (contracts of these functions are defined by users), where composite return structures are acceptable output for map and reduce functions, and where data storage structures are not optimized for specific results.

\subsubsection{The Reduce function contract}
It makes sense to define precisely what the contract for reduce functions is at this point (using the \textit{\_stats} function as an example, since this is the reduce funciton used in this project). All CouchDB reduce functions accept three arguments as summarized in \cite{reduceFunctions}:

\begin{enumerate}
    \item \textit{keys}: a list of tuples of the form \textless \textit{key}, \textit{id} \textgreater. \textit{key} is the key emitted by the map function, and \textit{id} is the id of the document that was processed by the map function to emit the key. This argument is null in the case of rereduce = true.
    \item \textit{values}: a list of the values emitted by the map function, with each value correlating to a the respective element in the \textit{keys} list (when rereduce = false). When rereduce = true, this argument is a list of values previously output by this reduce function.
    \item \textit{rereduce}: a boolean field indicating whether the function is invoked with output from the map function (rereduce = false), or previous output from this reduce function (rereduce = true). Reduce function results are cached on internal nodes in the B+tree view indexes to facilitate incremental tree updates without having to recalculate all reduce output (see appendix \ref{slack-25-oct}), making the rereduce contract necessary.
\end{enumerate}

Figure \ref{stats-reduce-fn} describes the contract of the \textit{\_stats} reduce function in terms of output as a result of the corresponding map function output (i.e. reduce function input). Writing custom reduce functions that adhere to the reduce function contract is fairly difficult for anything but the simplest examples; a custom implementation of the \textit{\_count} reduce function is shown in the appendix (see \ref{couchdb-mapreduce-contracts}) as an example.

\begin{figure}[ht]
    \begin{minted}{javascript}
/**
 * Example input to the _stats reduce function when rereduce = false (i.e. map function output)
 */
{"somKey": [1,1,0]}
{"somKey": [3,1,3]}
/**
 * Psudo intermediate step showing how the reduce function would treat the map output above
 * This is specifically the _stats function logic
 * Implementation would need to adhere to the reduce function contract
 */
{
    "someKey": [
        aggregate([1, 3]),
        aggregate([1, 1]),
        aggregate([0, 3]),
    ]
}
/**
 * Output from the _stats reduce function
 */
{"somKey": [
    {"sum":4,"count":2,"min":1,"max":3,"sumsqr":10}
    {"sum":2,"count":2,"min":1,"max":1,"sumsqr":2}
    {"sum":3,"count":2,"min":0,"max":3,"sumsqr":9}
]}
    \end{minted}
    \caption[\textit{\_stats} function contract]{The \textit{\_stats} function accepts either a single number or a list of numbers (as used in this project) as the \textit{values} argument for the reduce function. Grouping is performed per key, with values at corresponding indexes of the values list aggregated per common key. In the example above, two groupings are performed: 1) grouping per key output by Map function, and 2) as a key now corresponds to several lists, values in these lists are grouped by common indexes.}
    \label{stats-reduce-fn}
\end{figure}



\subsection{List functions}
List functions fall under the category of \textit{CouchApps} and, as mentioned previously, are likely to be excluded from future releases. These functions iterate a view output to an HTTP(S) client, allowing a final phase of transformation - i.e. a data format switch from JSON documents to CSV format. These  functions take the name of a \textit{MapReduce} view as an argument and iterate through the results, passing those results to a user over HTTP(S). As with all of CouchDB interactions, list functions are invoked via HTTP and allow for an API of retrieving data from CouchDB views. As mentioned in \ref{slack-2-nov}, list functions are deprecated and should be replaced by code external to the CouchDB application. This would not be very challenging, and software such as the bespoke ETL tool written for this project (\textit{nETL}) could be easily configured to replace list functions with a small amount of coding. But since \textit{List} functions are likely to enjoy several more years of support in the CouchDB current release and possibly in the future, they are still a useful tool and are relevant enough that there use is not unwarranted in this project.