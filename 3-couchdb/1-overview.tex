\subsection{CouchDB's MapReduce implementation}
CouchDB as a document store doesn't, in itself, provide a means of data-querying. Instead it allows for processing of database file(s) via MapReduce to produce separate files (\textit{Views}) that are derived from a single database. These derived sets of data are structured as B+Trees, as are the initial database files. To this extent, and as pointed out in \cite{couchguide}, CouchDB is effectively a B+tree engine that provides users a means of interacting directly with B+trees via an HTTP API. Via this API a user is able to interact directly with the database B+tree, to which all view files are linked; changes to a database file results in incremental adjustment of the view file via the specified MapReduce functions. So in a sense you donâ€™t 'query' couch. You actually specify a MapReduce task to create a completely separate store of data. And then you can interact with that data (specifically by searching) using the REST API.

In this sense the isolated nature of MapReduce (specifically the implementation in CouchDB) allows eager creation of 'query' output (if you were to consider view-generation as a means of 'querying' CouchDB) across huge, dispersed and highly available query output. Unlike in the traditional sense of 'MapReduce', Couch's reduce engine allows for partial groupings of a key via specifying the concept of 'rereduction' in the contract of the reduce function. More accurately, \textit{map} results are stored as B+ indexes within CouchDB including \textit{reduce} results on internal nodes (see \ref{appendix:slack1}). As mentioned on the original (and no longer maintained) CouchDB Wiki, \textit{map} output is sent the \textit{Reducer} in batches delimited by B+tree boundaries \cite{couchwiki}. Since grouping is done after this step by the \textit{Reducer}, reduce functions must allow for the case that not all values for a key are processed at once or by the same \textit{reduce} function. This allows for dispersed, partial and autonomous view calculation on any CouchDB node.

In terms of how MapReduce is executed in CouchDB, and possibly related to B+tree storage structures as mentioned above, grouping and reducing in CouchDB is handled by a 'master' node for any particular shard. Unlike a traditional implementation of MapReduce where \textit{Map} and \textit{reduce} tasks are executed in parallel, CouchDB spawns a single \textit{couchjs} process per shard (see \ref{appendix:slack3} and \ref{appendix:slack5}) and the map index is calculated sequentially according to a list of database changes as managed by CouchDB (available at the \textit{\_changes} endpoint).

Worth mentioning in the context of couchDB specifically, is the MapReduce engine used. CouchDB ships with an executable "couchjs.exe" - the \textit{javaScript} query-server - coupled with Mozilla's \textit{SpiderMonkey} runtime engine; this query engine is drop-in replaceable, although there is probably no motivation to do so. According to the documentation \cite{builtincouchreduce}, CouchDB has with a couple built-in reduce function - \_sum, \_count, and \_stats that are implemented as functions within the main Erlang process (as distinct from the mapping and reduction being handled by the main process) that perform substantially better than custom reduce functions since custom functions are not optimized and need to be executed externally to main process. This results in an I\/O overheard that is particularly severe on Windows machines (see \ref{appendix:slack3}).

Because of the nature of the \textit{reduce} function contract (allowing for rereduce = true), joins via MapReduce as described by \cite{chandar2010} are simply not possible. A SQL query of the form: \textit{R(a,b)} joined with \textit{S(b,c)} joined with \textit{T(c,d)} (where \textit{R}, \textit{S} and \textit{T} are relations and \textit{a}, \textit{b}, \textit{c}, \textit{d} are attributes) and expressed by the code (SQL Server syntax):

\begin{minted}{sql}
SELECT
[R].[a],
[T].[d]
FROM [R]
LEFT JOIN [S] on [S].[b] = [R].[b]
LEFT JOIN [T] ON [T].[c] = [S].[c]
\end{minted}

cannot be achieved without prior processing of all or some of the relations, or in the spirit of CouchDB, via multiple interactions with a view. If two or more entities were to be joined on a common field then it is theoretically possible to group these values in the reduce function and retrieve a 'joined' dataset that way, but CouchDB looks for this and warns users that this is NOT an appropriate use of CouchDB's view engine. CouchDB's optimization of it's B+tree storage structures means that the database complains when \textit{reduce} function output doesn't shrink compared to the input. There is a configurable setting in CouchDB \mintinline{javascript}{reduce_limit=false} that allows a user to override the default setting, but as mentioned in this project, such a configuration produced no results within a reasonable time frame. As one of the owners of CouchDB mentions, such a function would defeat the purpose of structuring the view results as an index and result in performance in terms of space and time of $ O(n^2) $ or worse (see \ref{appendix:slack2}).