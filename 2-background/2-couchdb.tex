\section{CouchDB}
In CouchDB, data is modeled conceptually as \textit{documents}, which users interact with as serialized JSON strings. There are no limitations/specifications/etc. on how documents may be structured (other than that they can be represented by valid JSON). The comprise \textit{key:value} pairs, in which the value may be objects themselves.

The CouchDB data model (like many NoSQL data models) is considered to be \textit{unstructured}, or \textit{semi-structured}, compared to RDBMSs where data models are rigidly formalized in terms of relations. But despite different storage models, conceptual requirements of data-persistence - such as well known ACID properties are applicable to all database systems. ACID properties provide certain guarantees required within a system to reliably persist information:

\begin{itemize}
    \item \textit{atomicity}: a series of operations part of the same logical transaction should either succeed or fail completely
    \item \textit{consistency}: building on the concept of atomicity, the result of a single logical transaction should leave the database in a working and valid state
    \item \textit{isolation}: Transactions, whether run concurrently or sequentially, are deterministic. That is, transactions on a database are performed in isolation of each other
    \item \textit{durability}: data is persisted permanently irrespective of subsequent system failures
\end{itemize}

Without such guarantees a database would not be useful since the integrity of any information stored in such a system would be questionable. In terms of the CouchDB software, ACID properties are applicable at the document level meaning that interactions with individual documents are either successful or not; CouchDB does not allow reading or writing of partial documents.

CouchDB serializes document interactions to guarantee isolation, document writes are guaranteed to be durable and result in a consistent database. In other words, in working with CouchDB, transactions involving single documents are completely reliable and fault tolerant. But transactions involving retrieving and storing information from multiple documents are not (although bulk document insertions can also be configured to be atomic).

Single-document ACID guarantees make multistep transactions in CouchDB more difficult. \textit{Multi-step transactional atomicity} is a key feature for many RDBMSs including MySQL, SQL Server, etc. and overcoming this limitation is something that is required in order to implement NoSQL databases in traditional RDBMS environments. This is possible, both in CouchDB specifically \cite{Rashmi2017} and NoSQL in general \cite{LOTFY2016133} via implementing ACID/transactional properties as bespoke middleware externally to these database management systems (DBMS). But it would seem this is not an ideal alternative to systems where RDBMS-specific features are required! This is a trade-off that CouchDB (and other NoSQL) databases make in favor of less rigorous data models that are suitable for use-cases that RDBMSs are not; namely, environments with semi-unstructured data where availability is more important than complete consistency.

CouchDB documents are written to disc via an \textit{append-only} algorithm, in which documents are incorporated into a b+tree structure, which is the database \cite{couchguide}. Such structures facilitate fast data retrieval from huge databases. Additionally, CouchDB incorporates \textit{Multiversion concurrency control} (MVCC) into the storage engine as a means of versioning nodes in the tree. Aside from write operations being serialized, MVCC negates the needs for locks that are typically implemented within RDBMSs and are expensive in terms of computer resources. Without locking on read/write operations, CouchDB data stores are infinitely available with the caveat that retrieved documents as found via searching the tree structure may not always be the most recent versions of those documents. This can be the case if a new version of a document were to be written whilst the same document is concurrently being retrieved.

Research in 1999 introduced the idea of the CAP theorem as a trade-off analysis of 3 properties of a data storage system, Consistency, Availability, and Partition-tolerance for systems faced with the potential for network downtime \cite{cap}. CouchDB represents a trade-off of \textit{consistency} for \textit{availability} to facilitate scalability in terms of handling large amounts of data in near-realtime. CouchDB emphasizes availability and eventual consistency of data to allow for high partition tolerance of databases with unreliable communication between nodes. From CouchDB 2.0 onwards users can configure the desired level of consistency of document reads by specifying a quantifiable amount of confidence that retrieved data is not out of date. But this is not possible for document writes.

Because of the potential for inconsistency, CouchDB seeks to provide a 'relaxed' viewing model - i.e. a \textit{soft state} where data representation is not tied to the underlying entities (an entity can be updated whilst being viewed unaware of such changes). That is, emphasizing \textit{availability} at the expense of \textit{consistency} as per the CAP theorem; data conflicts, where entities are updated separately and independently of each other are often acceptable in NoSQL databases, particularly in systems that are required to take an \textit{offline-first} approach to data-handling. These systems provide a means of interacting with partial datasets, that when synchronized could result in conflicting state.

MVCC allows for handling such consistency violations by maintaining consistency within the data storage layer itself that is separate from the consistency of information. Inconsistent (i.e. conflicting) information can be resolved by following the audit trail created by the MVCC mechanism. By maintaining database state separately to information-state, multi-master replication in highly available systems without strong consistency guarantees is possible.

CouchDB is usually selected as a database over alternative JSON stores (such as MongoDB) for it's replication capabilities - that is, for the ease at which multi-master, fault-tolerant clusters can be setup. Separation of database state from information greatly facilitates this. Compared to replication of relational systems (such as in SQL Server), replication is independent of information (i.e. table structure, relationships between tables, etc) and as a result is much simpler and easier to work with.

\subsection{Entity Modeling}
Despite NoSQL DBMSs moving away from the relational model as provided by RDBMSs, data models still focus on modeling \textit{entities}. Depending on what these entities constitute, these databases can be grouped into two categories \cite{fowlerAggregate}:

\begin{itemize}
    \item \textit{aggregate-orientated} stores that model data similarly to the relational model but with isolated entity boundaries and
    \item \textit{aggregate-ignorant} stores where the concept of entities is fundamentally different (e.g. a graph database such as Neo4J \cite{sadalage2012} where the entities are edges and nodes)
\end{itemize}

The vast majority of databases operate within a domain where data is (for the most part) entity-driven. There are hundreds of NoSQL data stores and a comprehensive categorization of such products is not sensible \cite{GANESHCHANDRA201513}, but familiar examples within the family of \textit{aggregate orientated} NoSQL databases include key-value stores such such as Amazon's Dynamo \cite{sadalage2012}, column based stores such as Apache's Cassandra \cite{sadalage2012} or HBase \cite{sadalage2012} (as part of the Hadoop ecosystem), and document stores such as CouchDB or Mongo \cite{sadalage2012}.

Although NoSQL databases are said to be \textit{schema-less}, this is somewhat of a misnomer \cite{ATZENI2016}; instead of being \textit{schema-less} NoSQL databases allow for inconsistent schema representation across different entity instances due to the nature of how entities are aggregated. Such flexibility is at the heart of document stores such as CouchDB and Mongo where loose-schema modeling is one of the properties that makes such technologies suitable for large systems that generate data from inconsistent sources.

JSON structure allows for forming hierarchical (tree) structures of infinite depth - i.e. for nesting child entities as sub-objects. As an alternative to relations where relationships are defined by key references, hierarchical structures allow for easily structuring specific entities, but are less suitable for working with classes of entities. As such, data is typically grouped differently in JSON documents compared to relational tables; objects encourage groupings of specific entities, while tabular relations encourage grouping entity types.

While it is straightforward to model composition (child entities that belong exclusively to parent entities) as objects, it is more difficult to model aggregations (child entities that are used by many different parent entities) and associations (entities that interact with other entities). Nested hierarchical structures are also less suitable for comparisons across child-entities. For example, a relational database may have a table of child-entities ``products'' where it would be easy to compare prices of the same product kept at many shops (parent entities); but a shop-product relationship modeled as hierarchical objects would first involve traversing every object of type ``shop'' to retrieve a list of products before a comparison could be made. Compared to the same analysis in a relational database, this is less performant. There is also a great deal of replicated data since a child entity would be repeated for every parent entity. As such, many NoSQL databases work with denormalized data models. The advantage of this is that entities of a single type may be structured differently according to requirement per object.

Because JSON is far less structured than relational tables, entities of the same entity-type may be represented via variable schemas. For example, two ``person'' objects represented via JSON might have the same properties relating to their name, age, address, etc. but these properties could be have different spellings (``name, ``Name'' or ``sName''), and values could be different data types (the value ``address'' could be a string for one person and a list of strings for another). To think of entities as rows of a relational table, each entity is allowed its own variety of columns in a JSON store with differing data types as values. In a relational database this would result in a sparse table where every row has to include the columns of every other row of the same entity type. Such a case would result in massive amounts of wasted storage and inefficient indexing. Since categorizing data in terms of entity type and properties is entirely logical in CouchDB, entity modeling is less strict.

But since CouchDB does not provide a means of differentiating between documents except by the content of each document, database content is not immediately classifiable in terms of relations, fields, constraints, etc., as can be done in RDBMSs. While MongoDB uses the idea of \textit{collections} that allow for categorizing different types of documents, CouchDB documents are only classifiable by retrieving and reading the entire document. Logical entity classification in CouchDB is usually enforced by including a field \textit{type}, that allows for logical handling of different entity types after document retrieval. Alternatively, entity classification can be included in the id field of CouchDB documents, which has the benefit of allowing indexed entity retrieval.