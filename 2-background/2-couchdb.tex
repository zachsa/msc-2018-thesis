\section{CouchDB}
In CouchDB, data is modeled conceptually as \textit{documents}, which users interact with as serialized JSON strings \cite{rfc7159}. There are no limitations, specifications, etc., on how documents may be structured (other than that they must be represented by valid JSON). These comprise key-value pairs, in which the value may be derived from the objects themselves.

The CouchDB data model (like many NoSQL data models) is considered \textit{unstructured} or \textit{semi-structured} when compared to RDBMSs, where relations within data models are rigidly formalized. But despite using different storage models, the conceptual requirements of data-persistence – such as ACID properties – need to be addressed. ACID properties provide certain guarantees that are required within a system in order to assure information persistence:

\begin{itemize}
    \item \textit{atomicity}: a series of operations that are part of the same logical transaction should either succeed or fail completely
    \item \textit{consistency}: building on the concept of atomicity, the result of a single logical transaction should leave the database in a working and valid state
    \item \textit{isolation}: Transactions, whether run concurrently or sequentially, are deterministic. That is, transactions on a database are performed in isolation of each other
    \item \textit{durability}: data is permanently persisted, irrespective of subsequent system failures
\end{itemize}

Without such guarantees a database would not be useful since the integrity of any information stored the system would be questionable. In terms of the CouchDB software, ACID properties are applicable at the document level, meaning that the interactions with individual documents are either successful or not; CouchDB does not allow the reading or writing of partial documents.

CouchDB serializes document interactions to guarantee isolation and document writes are guaranteed to be durable and result in a consistent database. In other words, in working with CouchDB, transactions involving single documents are completely reliable and fault tolerant; however, transactions involving retrieving and storing information from multiple documents are not (although bulk document insertions can also be configured atomically).

Single-document ACID guarantees make multistep transactions in CouchDB more difficult. \textit{Multi-step transactional atomicity} is a key feature for many RDBMSs including MySQL, SQL Server, etc., and overcoming this limitation is required in order to implement NoSQL databases within traditional RDBMS environments. This is possible, both in CouchDB specifically \cite{Rashmi2017} and in NoSQL generally, \cite{LOTFY2016133} via the implementation of ACID/transactional properties as external bespoke middleware that engages with the database management systems (DBMS). But this is not an ideal alternative to systems where RDBMS-specific features are required. This is a trade-off that CouchDB (and other NoSQL) databases make in favor of less rigorous data models that are suitable for use-cases that RDBMSs are not; namely, environments with semi-unstructured data where availability is more important than complete consistency.

CouchDB documents are written to disc using an \textit{append-only} algorithm, in which documents are incorporated into a b+tree structure, which is the database \cite{couchguide}. Such structures facilitate rapid data retrieval from huge databases. Additionally, CouchDB incorporates \textit{Multiversion concurrency control} (MVCC) into the storage engine as a means of versioning nodes within the tree. Aside from the serialization of write operations, MVCC negates the need for locks, which are typically implemented within RDBMSs and are expensive in terms of computer resources. Without locking on read/write operations, CouchDB data stores are always available, with the caveat that retrieved documents, as found through searching the tree structure, may not always be the most recent versions of those documents. This can be the case if a new version of a document is written whilst the same document is being retrieved elsewhere.

For systems faced with the potential of network downtime, research in 1999 introduced the idea of the CAP theorem as a trade-off analysis that can be applied to 3 properties within a data storage system (Consistency, Availability, and Partition-tolerance) \cite{cap}. CouchDB represents a trade-off of \textit{consistency} for \textit{availability} in order to facilitate scalability in terms of handling large amounts of data in nearly real time. CouchDB emphasizes availability and the eventual consistency of data to allow for a high partition tolerance of databases with unreliable communication between nodes. From CouchDB 2.0 onwards, users can configure the level of consistency for document reads by specifying a quantifiable amount of confidence that retrieved data is not out of date. It should be noted, however, that this is not possible for document writes.

Because of the potential for inconsistency, CouchDB seeks to provide a 'relaxed' viewing model - i.e. a \textit{soft state}, where data representation is not tied to the underlying entities. As part of the trade-off of availability at the expense of consistency, data conflicts - where entities are updated separately and independently of each other - are often acceptable in NoSQL databases, particularly in systems that are required to take an \textit{offline-first} approach to data-handling. Thus, these systems provide a means of interacting with partial datasets, which, when synchronized, could result in a conflicting state.

MVCC allows for the handling of such consistency violations by maintaining consistency within the data storage layer itself, which is separate from the consistency of information. Inconsistent (i.e. conflicting) information can be resolved by following the audit trail created by the MVCC mechanism. By maintaining a database state that is separate from the information-state, multi-master replication in highly-available systems that lack strong consistency guarantees is possible.

CouchDB is usually selected as a database over alternative JSON stores (such as MongoDB) for its replication capabilities - that is, for the ease with which multi-master, fault-tolerant clusters can be set up. The separation of the database state from the information greatly facilitates this. Compared to replication within relational systems (such as in SQL Server), here replication is independent of information (i.e. table structure, relationships between tables, etc.) and, as a result, is much simpler to work with.

\subsection{Entity Modeling}
Despite NoSQL DBMSs moving away from the relational model provided by RDBMSs, data models still focus on modeling entities. Depending on what these entities constitute, the databases can be grouped into two categories \cite{fowlerAggregate}:

\begin{itemize}
    \item \textit{aggregate-orientated} stores that model data similarly to the relational model, but with isolated entity boundaries and
    \item \textit{aggregate-ignorant} stores, wherein the concept of entities is fundamentally different (e.g. a graph database such as Neo4J \cite{sadalage2012}, where the entities are edges and nodes)
\end{itemize}

Most databases operate within a domain where data is, for the most part, entity-driven. There are hundreds of NoSQL data stores and a comprehensive catalog of such products is not necessary \cite{GANESHCHANDRA201513}, but familiar examples within the family of aggregate-orientated NoSQL databases include key-value stores such as Amazon's Dynamo \cite{sadalage2012}; column based stores such as Apache's Cassandra \cite{sadalage2012} or HBase \cite{sadalage2012} (as part of the Hadoop ecosystem); and document stores such as CouchDB or Mongo \cite{sadalage2012}.

Although NoSQL databases are said to be \textit{schema-less}, this is something of a misnomer \cite{ATZENI2016}: NoSQL databases allow for inconsistent schema representation across different entity instances due to the nature of how entities are enforced. Such flexibility is at the heart of document stores such as CouchDB and Mongo, where loose-schema modeling is one of the properties that makes such technologies suitable for large systems that generate data from inconsistent sources.

JSON structure allows for forming hierarchical (tree) structures of infinite depth - i.e. for nesting child entities as sub-objects. As an alternative to relationships that are defined by key references, hierarchical structures allow for the easy structuring of specific entities but are less suitable for working with classes of entities. As such, data is typically grouped differently in JSON documents as compared to relational tables; objects encourage groupings of specific entities, while tabular relations encourage the grouping of entity types.

Using hierarchical object structures, it is easy to implement compositional object models, where entities are encapsulated exclusively within parent entities. Aggregational and associative relationships (i.e. \textit{many-many} associations), however, require that data be denormalized, which results in replicated information. This is inefficient but advantageous for dealing with entities whose instances have varying data structures. For example, it is conceivable that the instance of a \textit{Person} entity could have different fields, with similar fields holding different types of data (e.g., a person may have a single address or a list of addresses).

To think of entities as rows within a relational table, each entity represented via JSON is allowed a unique list of columns featuring differing data types as values. In a relational database this would result in a sparse table where every row must include the columns of every other row of the same entity type. Such a case would result in a massive amount of wasted storage and inefficient indexing.

Entity modeling in CouchDB is quite flexible. RDBMSs allow for the categorization of information in terms of relations, fields, constraints, and other objects, while MongoDB documents are identifiable in terms of \textit{collections}. CouchDB does not provide a built-in means of classifying documents, except by scanning an entire database and reading each document.

Entity classification can be enforced by including a field \textit{type} that allows for entity modeling to be conducted separately from the data-storage engine. With this approach, documents are only classifiable on retrieval and deserialization. Alternatively, entity classification can be included in the \textit{\_id} field of CouchDB documents, which has the benefit of allowing for indexed entity retrieval.