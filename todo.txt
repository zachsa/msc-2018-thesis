1. include additional info in chapter 2
4. change benchmarks to 'admissions'
5. data types should be lower cased
7. search and assess \textit brackets
10. Map/map List/list capitalization

I will fill in the blank table (netl times, couchdb footprint, etc) tomorrow by taking an everage of 3 instances of each operations



Did you compare the correlations, variances and std deviations with a relational database result, or with Excel, or on a small dataset with manual calculations?




If time: look at stats and sum function sections again





Some CouchDB join stuff


Because of the nature of the \textit{reduce} function contract (allowing for rereduce = true), and in conjunction with how reduce output is stored in the b+tree, joins via MapReduce as described by \cite{chandar2010} are simply not possible. A SQL query of the form: \textit{R(a,b)} joined with \textit{S(b,c)} joined with \textit{T(c,d)} (where \textit{R}, \textit{S} and \textit{T} are relations and \textit{a}, \textit{b}, \textit{c}, \textit{d} are attributes) cannot be achieved without prior processing of all or some of the relations, or in the spirit of CouchDB, via multiple interactions with a view.

Although a 2-way join is conceptually possible as CouchDB MapReduce output (for example a reduce function could just return a list of all documents with the same key), this would result in expanding reduce output that may cause out-of-memory exceptions in the \textit{couchjs} MapReduce engine, and increasingly expensive memory and space usage towards the root node of the b+tree. This is a misuse of CouchDB's query engine \cite{reduceFunctions}. Reduce functions in CouchDB views are specifically optimized to allow incremental index alterations (i.e. incrementally altering the view index in response to a document added to the database). Because reduce output is stored as internal nodes of the b+tree index of map-output (which is ordered by map key), reduce results are still identifiable by output key in the tree and can be further grouped at higher levels in the tree with the reduce results from other nodes with the same key \cite{slack25Oct}. This is unlike other implementations of MapReduce, for example for Hadoop, where MapReduce tasks may comprise 'pipelines' of multiple map and reduce phases (contracts of these functions are defined by users). Composite return structures are acceptable output for MapReduce tasks or data structures other than used in indices. Hadoop (for example) is a less opinionated MapReduce implementation in this sense since since output data-structures are defined by the MapReduce tasks and not the Hadoop software in itself.