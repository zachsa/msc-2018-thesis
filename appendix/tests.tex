\section{nETL Unit Tests}

\subsection{FLATFILE}
Test code
\label{FLATFILE-tests}
\begin{minted}{javascript}
'use strict';
const assert = require('assert');
const path = require('path');

const e = {
    "Name": "FLATFILE",
    "path": path.join(__dirname, '/test.csv'),
    "skipHeaderRows": 1,
    "bufferSize": 65536,
    "batchSize": 1,
    "startFrom": 0,
    "afterTaskRunCBs": []
};

describe('CSV Parsing', function() {
    it("Returns all the lines in a CSV", function() {
        const m = require('../index.js').exe.call(e);
        var row = m.getNext();
        var c = 1;
        while (!row.done) {
            c++;
            row = m.getNext();
        };
        assert.equal(c, 16);
    });
    it("Returns single rows at a time", function() {
        const m = require('../index.js').exe.call(e);
        var row = m.getNext();
        for (let i = 0; i < 5; i++) {
            row = m.getNext();
        };
        const vals = row.value;
        assert.equal('Row 7 Column 1,Row 7 Column 2,Row 7 Column 3,Row 7 Column 4,Row 7 Column 5', vals);
    });
});
\end{minted}

Test CSV
\label{FLATFILE-CSV}

\begin{mdframed}[rightline=false,leftline=false]
    \centering
    \begin{BVerbatim}[fontsize=\tiny]

        +-----------------+-----------------+-----------------+-----------------+-----------------+
        |    Header 1     |    Header 2     |    Header 3     |    Header 4     |    Header 5     |
        +-----------------+-----------------+-----------------+-----------------+-----------------+
        | Row 2 Column 1  | Row 2 Column 2  | Row 2 Column 3  | Row 2 Column 4  | Row 2 Column 5  |
        | Row 3 Column 1  | Row 3 Column 2  | Row 3 Column 3  | Row 3 Column 4  | Row 3 Column 5  |
        | Row 4 Column 1  | Row 4 Column 2  | Row 4 Column 3  | Row 4 Column 4  | Row 4 Column 5  |
        | Row 5 Column 1  | Row 5 Column 2  | Row 5 Column 3  | Row 5 Column 4  | Row 5 Column 5  |
        | Row 6 Column 1  | Row 6 Column 2  | Row 6 Column 3  | Row 6 Column 4  | Row 6 Column 5  |
        | Row 7 Column 1  | Row 7 Column 2  | Row 7 Column 3  | Row 7 Column 4  | Row 7 Column 5  |
        | Row 8 Column 1  | Row 8 Column 2  | Row 8 Column 3  | Row 8 Column 4  | Row 8 Column 5  |
        | Row 9 Column 1  | Row 9 Column 2  | Row 9 Column 3  | Row 9 Column 4  | Row 9 Column 5  |
        | Row 10 Column 1 | Row 10 Column 2 | Row 10 Column 3 | Row 10 Column 4 | Row 10 Column 5 |
        | Row 11 Column 1 | Row 11 Column 2 | Row 11 Column 3 | Row 11 Column 4 | Row 11 Column 5 |
        | Row 12 Column 1 | Row 12 Column 2 | Row 12 Column 3 | Row 12 Column 4 | Row 12 Column 5 |
        | Row 13 Column 1 | Row 13 Column 2 | Row 13 Column 3 | Row 13 Column 4 | Row 13 Column 5 |
        | Row 14 Column 1 | Row 14 Column 2 | Row 14 Column 3 | Row 14 Column 4 | Row 14 Column 5 |
        | Row 15 Column 1 | Row 15 Column 2 | Row 15 Column 3 | Row 15 Column 4 | Row 15 Column 5 |
        | Row 16 Column 1 | Row 16 Column 2 | Row 16 Column 3 | Row 16 Column 4 | Row 16 Column 5 |
        +-----------------+-----------------+-----------------+-----------------+-----------------+

    \end{BVerbatim}
\end{mdframed}


\subsection{COUCHDB}
\label{COUCHDB-tests}
\begin{minted}{javascript}
'use strict';
const assert = require('assert');

const data = [
    { a: "a", b: "b", c: "c" },
    { a: "a2", b: "b2", c: "c2" },
    { a: "a3", b: "b3", c: "c3" }
];

describe('CouchDB loading:', function() {
    it("Batch load recieves 201 response", function() {
        const l = {
            "Name": "COUCHDB",
            "username": "admin",
            "password": "password",
            "server": "localhost",
            "port": 5984,
            "ssl": false,
            "database": "test"
        };
        const m = require('../index.js').exe.call(l);
        m.batch(data)
            .then(function(res) {
                assert.equal(res, 201);
            })
            .catch(function(msg) {
                assert.fail("Loading data into CouchDB did not succeed: " + msg);
            })
    });
});
\end{minted}

\subsection{TEXT\_LINE\_TO\_OBJ}
\label{TEXT_LINE_TO_OBJ-tests}
\begin{minted}{javascript}
'use strict';
const assert = require('assert');

describe('CSV values:', function() {
    describe('Are correctly split:', function() {
        const t = {
            "Name": "TEXT_LINE_TO_OBJ",
            "attributeNames": "h1,h2,h3",
            "delimiter": ",",
            "textQualifier": "\"",
            "escapeChar": "\\",
            "afterTaskRunCBs": []
        };
        it(`"a,1,true" is split into 3 ordered columns via a standard delimiter (,)`, function() {
            const m = require('../index.js').exe.call(t);
            const result = m.transform("a,1,true");
            const vals = Object.values(result);
            const valCount = vals.length;
            assert.equal(3, valCount);
            assert.equal(vals[0], 'a');
            assert.equal(vals[1], '1');
            assert.equal(vals[2], 'true');
        });
        it(`"a;1;true" is split into 3 ordered columns via alternative delimiter (;)`, function() {
            const t = {
                "Name": "TEXT_LINE_TO_OBJ",
                "delimiter": ";",
                "attributeNames": "h1;h2;h3",
                "textQualifier": "\"",
                "escapeChar": "\\",
                "afterTaskRunCBs": []
            };
            var m = require('../index.js').exe.call(t);
            var result = m.transform("a;1;true");
            const vals = Object.values(result);
            const valCount = vals.length;
            assert.equal(3, valCount);
            assert.equal(vals[0], 'a');
            assert.equal(vals[1], '1');
            assert.equal(vals[2], 'true');
        });
        it(`"a;1;true" is split into 3 ordered columns via a complex delimiter (|~|)`, function() {
            var t = {
                "Name": "TEXT_LINE_TO_OBJ",
                "delimiter": "|~|",
                "attributeNames": "h1|~|h2|~|h3",
                "textQualifier": "\"",
                "escapeChar": "\\",
                "afterTaskRunCBs": []
            };
            var m = require('../index.js').exe.call(t);
            var result = m.transform("a|~|1|~|true");
            const vals = Object.values(result);
            const valCount = vals.length;
            assert.equal(3, valCount);
            assert.equal(vals[0], 'a');
            assert.equal(vals[1], '1');
            assert.equal(vals[2], 'true');
        });
        it(`Headers are matched to the correct columns`, function() {
            const m = require('../index.js').exe.call(t);
            const result = m.transform("a,1,true");
            assert.equal(result['h1'], 'a');
            assert.equal(result['h2'], '1');
            assert.equal(result['h3'], 'true');
        });
        it(`JavaScript objects are created`, function() {
            const m = require('../index.js').exe.call(t);
            const result = m.transform("a,1,true");
            assert.equal('object', typeof result);
        });
    });

    describe('Are parsed corectly:', function() {
        it('Values can be wrapped by a qualifier (")', function() {
            var t = {
                "Name": "TEXT_LINE_TO_OBJ",
                "delimiter": ",",
                "attributeNames": "\"h1\",\"h2\",\"h3\"",
                "textQualifier": "\"",
                "escapeChar": "\\",
                "afterTaskRunCBs": []
            };
            var m = require('../index.js').exe.call(t);
            var result = m.transform("v1,\"2\",true");
            assert.equal(result.h1, 'v1');
            assert.equal(result.h2, 2);
            assert.equal(result.h3, 'true');
        });
        it("Date conversion is implicit", function() {
            var t = {
                "Name": "TEXT_LINE_TO_OBJ",
                "delimiter": ",",
                "attributeNames": "\"h1\",\"h2\",\"h3\"",
                "textQualifier": "\"",
                "escapeChar": "\\",
                "afterTaskRunCBs": []
            };
            var m = require('../index.js').exe.call(t);
            var result = m.transform("v1,\"2016-02-08 12:47:45\",true");
            assert.equal(result.h1, 'v1');
            assert.equal(Object.prototype.toString.call(result['h2']), '[object Date]');
            assert.equal(result.h3, 'true');
        });
    });
});
\end{minted}

\subsection{FILTER}
\label{FILTER-tests}
\begin{minted}{javascript}
'use strict';
const assert = require('assert');

const objs = [
    { a: "a", b: "b", c: "c" },
    { a: "a2", b: "b2", c: "c2" },
    { a: "a3", b: "b3", c: "c3" }
];

describe('Objects can be filtered by:', function() {
    it("A single value for a single attribute:", function() {
        const t = {
            "Name": "FILTER",
            "filterOn": {
                "a": ["a"]
            }
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        assert.equal(objs[0], result[0]);
        assert.equal(null, result[1]);
        assert.equal(null, result[2]);
    });
    it("Multiple values for a single attribute:", function() {
        const t = {
            "Name": "FILTER",
            "filterOn": {
                "a": ["a", "a2"]
            }
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        assert.equal(objs[0], result[0]);
        assert.equal(objs[1], result[1]);
        assert.equal(null, result[2]);
    });
    it("A single values for a multiple attribute:", function() {
        const t = {
            "Name": "FILTER",
            "filterOn": {
                "a": ["a"],
                "b": ["b"],
            }
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        assert.equal(objs[0], result[0]);
        assert.equal(null, result[1]);
        assert.equal(null, result[2]);
    });
    it("Multiple values for a multiple attribute:", function() {
        const t = {
            "Name": "FILTER",
            "filterOn": {
                "a": ["a", "a2"],
                "b": ["b", "b2"],
            }
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        assert.equal(objs[0], result[0]);
        assert.equal(objs[1], result[1]);
        assert.equal(null, result[2]);
    });
    it("Filtered objects meet all filter conditions:", function() {
        const t = {
            "Name": "FILTER",
            "filterOn": {
                "a": ["a", "a2"],
                "b": ["b"],
            }
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        assert.equal(objs[0], result[0]);
        assert.equal(null, result[1]);
        assert.equal(null, result[2]);
    });
});
\end{minted}

\subsection{CREATE\_OBJECT\_FIELD}
\label{CREATE_OBJECT_FIELD-tests}
\begin{minted}{javascript}
'use strict';
const assert = require('assert');

const objs = [
    { a: "a", b: "b", c: "c" },
    { a: "a2", b: "b2", c: "c2" },
    { a: "a3", b: "b3", c: "c3" }
];

describe('Attributes can be appended to objects:', function() {
    it("A single attribute can be added to objects:", function() {
        const t = {
            "Name": "CREATE_OBJ_FIELD",
            "newAttributes": [
                ["type_", "test"]
            ]
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        result.forEach(function(item) {
            assert.strictEqual(item.type_, "test");
        });
    });
    it("Multiple attribute can be added to objects:", function() {
        const t = {
            "Name": "CREATE_OBJ_FIELD",
            "newAttributes": [
                ["type_", "test"],
                ["otherAttribute", "test2"],
            ]
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        result.forEach(function(item) {
            assert.strictEqual(item.type_, "test");
            assert.strictEqual(item.otherAttribute, "test2");
        });
    });
    it("New key:value pairs added to objects are type sensitive:", function() {
        const t = {
            "Name": "CREATE_OBJ_FIELD",
            "newAttributes": [
                ["bool", false],
                ["bool2", true],
                ["int", 10]
            ]
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        result.forEach(function(item) {
            assert.strictEqual(item.bool, false);
            assert.strictEqual(item.bool2, true);
            assert.strictEqual(item.int, 10);
        });
    });
});
\end{minted}

\subsection{WHITELIST}
\label{WHITELIST-tests}
\begin{minted}{javascript}
'use strict';
const assert = require('assert');

const objs = [
    { a: "a", b: "b", c: "c" },
    { a: "a2", b: "b2", c: "c2" },
    { a: "a3", b: "b3", c: "c3" }
];

describe('Attributes can be appended to objects:', function() {
    it("A single attribute can be added to objects:", function() {
        const t = {
            "Name": "CREATE_OBJ_FIELD",
            "newAttributes": [
                ["type_", "test"]
            ]
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        result.forEach(function(item) {
            assert.strictEqual(item.type_, "test");
        });
    });
    it("Multiple attribute can be added to objects:", function() {
        const t = {
            "Name": "CREATE_OBJ_FIELD",
            "newAttributes": [
                ["type_", "test"],
                ["otherAttribute", "test2"],
            ]
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        result.forEach(function(item) {
            assert.strictEqual(item.type_, "test");
            assert.strictEqual(item.otherAttribute, "test2");
        });
    });
    it("New key:value pairs added to objects are type sensitive:", function() {
        const t = {
            "Name": "CREATE_OBJ_FIELD",
            "newAttributes": [
                ["bool", false],
                ["bool2", true],
                ["int", 10]
            ]
        };
        const m = require('../index.js').exe.call(t);
        const result = objs.map(function(obj) {
            return m.transform(obj)
        });
        result.forEach(function(item) {
            assert.strictEqual(item.bool, false);
            assert.strictEqual(item.bool2, true);
            assert.strictEqual(item.int, 10);
        });
    });
});
\end{minted}