\section{Overview}
As mentioned previously, CouchDB views are optimized when using built-in reduce functions, with custom reduce functions performing most poorly on Windows machines. As this project was completed on the Windows OS, the analysis on how best to aggregate the different entities (grades, demographics and events) was confined to using just the \textit{\_stats} built in reduce function. The output of this function overlaps output of the other two built-in reduce functions (\textit{\_count}, \textit{\_sum} (and provides additional metrics). Using custom reduce functions would greatly increase the number of possible methods of joining entities since output of map functions would not be constrained to match the contracts of the built-in functions. Such an approach shouldn't be discounted considering that on platforms other than Windows, reduce function calculation (whether custom or built-in) represents a small percentage of computer resources used in view calculations overall (see appendix \ref{slack-1-nov}). And in any case, a system that utilizes CouchDB is likely to be based on a cluster of Linux machines rather than a single Windows machine.

The \textit{\_stats} function signature requires that map output adhere to the following constraints: that values are either a single number or a list of numbers, that values (if lists) should be of the same length, and that indexes in value-lists each correlate with each other in terms of what the value at each index represents. Joining across the 3 entities (Demographics, Grades and Events), in adherence with the \textit{\_stats} function contract, requires emitting common keys in the map function on which grouping can be performed. To maintain the resolution that exists within the Grade data, that is; \textit{results of a particular student in a particular year for a particular course}, a compound key of the tuple \textless studentID, courseCode, year \textgreater is used for grouping, i.e. for every document processed by the map function, a key:value pair with a key in the form of that tuple needs to be emitted. Emitting this compound key is straightforward for grade data since each document of \textit{type\_} courseGrade has fields for all three of these values. However, neither the demographic nor the event data contains fields for 'courseCode', and student benchmarking in the demographic data are only for the year that student first registered. As such, of the required fields to output the key for joining, Demographic data only contains a 'studentID' field. Documents of \textit{type\_} 'sakaiEvent' include fields for studentId and year, but not courseCode (there is a FK field \textit{course\_id}) but it doesn't point to any field in the grade data.

To produce a key of the tuple \textless studentID, courseCode, year \textgreater for demographic data, the courseCode and year value have to be fabricated. In other words, demographic data has to be duplicated for every possible key combination on which it could be joined. In this case a single demographic document needs to be output for every course that a student can take, and then further duplicated for every year in which a student could take that course. Likewise the event data, which has fields for studentID and year, needs to be duplicated for every course that a student can take. Such an approach to joining is the basis of this analysis, which is done in iterations. Each iteration increases the volume of data processed by the map function so as to get insight in the effectiveness of this approach to joining documents. Analyses are discussed in terms of the results of each iteration. In general, each analysis involves 4 phases of data-wrangling:

\begin{enumerate}
    \item Configuring \textit{nETL} to load the required data
    \item Writing a Map function to perform the join (along with the \textit{\_stats} reduce function)
    \item Retrieving the index output (the view) via a List function, which transform the MapReduce output into tabular (CSV) data
    \item Manipulation of derived dataset in Excel
\end{enumerate}

Configurations used for \textit{nETL} for all the runs done while creating the analysis described below are shown in the appendix - see \ref{netl-run1-config}). Runtime results of \textit{nETL}, CouchDB indexing times, database/index storage footprints are shown in Table \ref{performance-analysis}. Initial CouchDB view calculation was performed on a local machine, but subsequently to achieving the analysis results, indexing time was compared on different cluster sizes. These times are shown in \ref{couch-indexing}. As seen in the table, increasing the cluster size reduces the time taken to index a database as per the described \textit{MapReduce} function decreases. This is as expected since dispersing documents across shards should be random enough that documents get distributed across shards uniformly (see \ref{slack-7-nov}), meaning that increasing nodes in a cluster reduces the amount of work a node must do when calculating \textit{map} output. However, it is likely that small data sets would not benefit from clustering since there is a high network overhead of sharded databases.

\section{Join of Grades/Demographics}
For a join on the Grades and Demographics entities, the map function is configured to output key-value pairs of the form: \textless studentID, courseCode, year \textgreater : <9 element list>. A description of the 11-element value list is shown in \ref{grades-join-demographics-output}. Configuration for the \textit{nETL} task is shown in the appendix (see \ref{netl-config-grades-join-demographics}), as is the Map function and list function (see\ref{msc-design-doc}).

The list shown in \ref{grades-join-demographics-output} shows ALL the values output by a map function on the join between all three entities. For the first two runs, event information is NOT emitted.

\begin{figure}[ht]
    \centering
    \begin{minted}{javascript}
 [
    // Grade Entitty output
    "CSC1015F %",

    // Demographic Entity output
    "Gr12 Eng %", 
    "Gr12 Sci %",
    "Gr12 Mth %",
    "Gr12 Mth Lit %",
    "Gr12 Mth Adv %",
    "NBT AL %",
    "NBT QL %",
    "NBT Mth %",

    // Event entity output
    "eventCount S1", // Only included for Run 3/4
    "eventCount S2" // Only included for Run 3/4
 ]    
    \end{minted}
    \caption[2-way-join map output]{\textbf{Figure \ref{grades-join-demographics-output}: Output of map function for grades joined with demographics.} This list, shown as a JavaScript array, is the key to the map function output. In other words, the map function outputs a list of values that correspond to this list. When retrieving the view output, headers can be given back to the columns retrieved using this key. View output can be achieved via a List function (as has been done in this project), or via bespoke JavaScript code.}
    \label{grades-join-demographics-output}
\end{figure}

% Runs
\input{6-analysis/2-join-runs}

\section{join of Grades/Demographics/Events}

% Runs
\input{6-analysis/3-join-runs}
