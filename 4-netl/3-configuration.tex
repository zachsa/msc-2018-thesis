\subsection{Configuration}

\textit{nETL} is configured first by the Extraction, Transformation and Load modules that a user loads, and then by the JSON configuration passed to the \textit{nETL} process during runtime to start the ETL task. The JSON configuration format is largely dependent on the E/T/L modules loaded, and in effect, has a user-defined API. Adding modules to the framework makes them available to tasks as specified by configuration objects. In this project the following modules were written and loaded, with example configurations shown in the methodology section.

\begin{enumerate}
    \item \textit{netl-extract-flatfile}
    \item \textit{netl-trans-create-obj-field}
    \item \textit{netl-trans-filter}
    \item \textit{netl-trans-text-line-to-obj}
    \item \textit{netl-trans-whitelist}
    \item \textit{netl-load-couchdb}
\end{enumerate}

As shown in \ref{nETL}, these modules must adhere to a contracts stipulated by \textit{nETL}'s module-loading interface. Modules are loaded into \textit{nETL}'s memory via the following code:

\begin{minted}{javascript}
// Load the module into memory
memoryObject[userModule.name] = userModule.exe;

// Invoke the module's closure
var loadedModule = memoryObject[userModule.Name].call(userModule);

// Genrate batch from extraction module
var batch = loadedModule.getNext()

// Do transformations on batch
batch = loadedModule.transform(batch);

// Load transformed batch
load.batch(batch).then(function(msg) {}).catch(function(msg) {});

// An example userModule (an extraction module)
userModule = (function() {
    function exe(configurationObj) {
        function getNext() { /* ... */};
        return {
            getNext: getNext
        };
    };
    return {
        name: "MODULE_NAME",
        exe: exe
    };
})();
\end{minted}