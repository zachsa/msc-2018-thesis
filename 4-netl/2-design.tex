\subsection{Design}

\begin{figure}[H]
    \centering
    \begin{mdframed}
        \centering
        \includegraphics[scale=0.092]{./resources/figures/netlUML.png}
    \end{mdframed}
    \caption[nETL Architecture]{\textbf{Figure \ref{nETL}: nETL Architecture.} \textit{nETL} is an ETL framework designed to host user-created \textit{Modules} to define \textit{extraction}, \textit{transformation} and \textit{loading} processes. \textit{Modules}, shown in the colored boxes, consist of two parts: a configuration object (a JSON object) and a function that adheres to the specified contract. On startup the \textit{nETL} framework loads modules via the operations via a function made available by the main class. The modules are then cached in main memory by the \textit{nETL} process. A user can then interact with the TaskManager class to create a new task via loading a JSON configuration that makes use of a particular \textit{Module}. Tasks consist of an \textit{Extraction module} configuration, several \textit{Transformation module} configurations and a \textit{Load} configuration. Because modules are created and defined by users, as well as the order in which modules are executed, input/output contracts are also defined by the user, and as such \textit{ETL} processes are infinitely configurable.}
    \label{nETL}
\end{figure}


Figure \ref{nETL} shows a potential architecture for a configurable component-based ETL tool. The intention of the framework is that it works on the basis of a pipeline of tasks. The framework itself is quite lightweight and comprises just the NETL, TaskManager and general purpose 'Tools' classes. For the purposes of this thesis, the framework as described by Figure \ref{nETL} has been prototyped in node.js. \textit{JavaScript} is a suitable language to prototype this application for a number of reasons:

\begin{enumerate}
    \item It has a very succinct API making it fast to write code in (i.e. it is a highly abstracted language similarly to Ruby or Python)
    \item But unlike Ruby or Python (and other high level languages), it is opinionated in that it handles IO asynchronously by default
    \item The \textit{JavaScript} implementation of object-orientation is appealing (to some developers at least)
    \item And working and learning \textit{JavaScript} is very much in line with the spirit of CouchDB and the web in general
\end{enumerate}

nETL is primarily a task-managing application, and as such, the TaskManager class is effectively the core of the application with implementation shown in \ref{appendix:netl-taskmanager}. The application itself is intended to be singleton instance of \mintinline{javascript}{class NETL{}}, which provides an interface to \textit{TaskManager}, and modular extraction/transformation and load operations. Singleton's are typically implemented via the modular pattern in JavaScript, which is typically how libraries are delivered to users by package managers and invoked by \mintinline{javascript}{var library = require('library-name')();}. The core \textit{nETL} singleton instance is available in the appendix at \ref{appendix:netl-main}.

To achieve batches loading, \textit{JavaScript} generators are are used. As described by \cite{mozillaGenerators}, \textit{JavaScript} generators allow for quickly implementing arbitrary iterators, including iterators over generated iterators. Using open source code provided by \cite{bower16}, nETL makes use of a generator function iterate of the lines of a file, and then a higher level generator to iterate over results of the line generator to produce \textit{batches} of data that are worked through the ETL pipeline. See \ref{appendix:netl-extraction} for an example of \textit{nETL}'s batch extraction mechanism that makes use of JavaScript generators.

Transformations are then applied to batches of lines, with the result passed to a loading function. The loading function is implemented asynchronously due to the time-cost involved when using IO (and specifically using network IO as possible with CouchDB). As batches are successfully loaded, a new batch is extracted for processing via recursion (see \ref{appendix:netl-engine} for a code sample of the recursive \textit{nETL} engine for extracting, transforming, and loading batches).