\section{CouchDB}
CouchDB falls under the very general classification of ``NoSQL'' (\textit{N}ot \textit{o}nly \textit{SQL}) databases - indicating a class of databases where data modeling is not strictly limited to tabular relations. CouchDB, for example, is a document store; persisted data comprises numerous JSON strings (i.e. the `documents') with no inherent limitation or specification as to the structure of these documents (other than that each is a of valid JSON format). But despite different storage models, conceptual requirements of data-persistence - such as well known \textit{ACID} properties are applicable to all database systems. The acronym \textit{ACID} stands for:

\begin{enumerate}
    \item \textit{A}tomicity: a series of operations part of the same logical transaction should either pass or fail completely
    \item \textit{C}onsistency: building on the concept of atomicity, the result of a single logical transaction should leave the database in a working and valid state
    \item \textit{I}solation: transactions on a database are self contained and don't interact with each other
    \item \textit{D}urability: data is persisted permanently and reliably as a result of isolated transactions that leave the database in a consistent state due to their atomicity in nature
\end{enumerate}

Without strictly adhering to such constraints, a database would not be useful since without these guarantees persisted data could not be trusted. In terms of CouchDB, \textit{ACID} guarantees are implemented at the level of a single document, meaning that transactions involving single documents are completely reliable and fault tolerant, but transactions involving retrieving and storing information from multiple documents are not. Single-document \textit{ACID} guarantees make multistep transactions in CouchDB more difficult. "Multi-step transactional atomicity" is a key feature for many RDBMSs including \textit{MySQL}, \textit{SQL Server}, etc. and overcoming this limitation is something that is required in order to implement NoSQL databases in traditional RDBMS environments. This is possible, as shown by \cite{Rashmi2017} for CouchDB specifically and NoSQL in general \cite{LOTFY2016133} via implementing \textit{ACID}/transactional properties as bespoke middleware externally to these DBSs. But it would seem this is not an ideal alternative to systems where RDBMS-specific features are required! This is a trade-off that CouchDB (and other NoSQL) databases make in favor of less rigorous data models that are suitable for use-cases that RDBMSs are not.

In terms of implementation, a brief description of CouchDB's internals is discussed in online documentation \cite{couchguide}. The salient points are:

\begin{enumerate}
    \item JSON strings are appended to database files that are structured as b+trees optimized for fast data retrieval from huge databases
    \item that B+ tree implementation incorporates a MVCC (Multi-Version-Concurrency-Control) model
    \item and that disc-writing is done via an 'append-only' approach
\end{enumerate}

Aside from write operations being serialized, MVCC negates the needs for locks that are typically implemented within RDBMSs and are expensive in terms of computer resources. Without locking on read/write operations, CouchDB data stores are infinitely available with the caveat that such available documents may not always be the most recent versions of those documents. Research in 1999 by \cite{cap} introduced the idea of the \textit{CAP} theorem as a trade-off analysis of 3 properties of a data storage system\textit{Consistency}, \textit{Availability}, and \textit{Partition-tolerance} faced with the inevitability of network downtime (all three properties ARE fully achievable without network downtime). CouchDB represents a trade-off of \textit{consistency} for \textit{availability} to facilitate scalability in terms of handling large amounts of data in near-realtime. CouchDB emphasizes \textit{availability} and \textit{eventual consistency} of databases to allow for high partition tolerance of databases with unreliable communication between nodes. From CouchDB 2.0 onwards users can configure the desired level of consistency of document reads, but not document writes.

Because of the potential for inconsistency, CouchDB seeks to provide a 'relaxed' viewing model - i.e. a \textit{soft state} where data representation is not tied to the underlying entities (an entity can be updated whilst being viewed unaware of such changes). That is, sacrificing of \textit{availability} at the expense of \textit{consistency} as per the \textit{cap} theorem; data conflicts, where entities are updated separately and independently of each other are often acceptable in NoSQL databases - particularly in an offline-first approach to data-handling. CouchDB handles such consistency violations via an implementation of MVCC (multi-version concurrency control) that involves a versioning of each document during write. Such an audit trail allows for handling of cases where consistency is violated.

\subsection{Entity modeling}
Despite moving away from the relational model as provided by RDBMSs, the concept of 'entities' is usually still highly relevant in many NoSQL databases; these database can, as such, be grouped into two categories:

\begin{enumerate}
    \item \textit{aggregate orientated} stores that model data similarly to the relational model but with isolated entity boundaries (\cite{fowlerAggregate}) and
    \item \textit{aggregate ignorant} stores where the concept of entities is fundamentally different (e.g. a graph database such as \textit{Neo4J} where the entities are edges and nodes)
\end{enumerate}

By far, most databases operate within a domain where data is for the most part entity-driven. The family of \textit{aggregate orientated} NoSQL data stores include \textit{key/value} stores such such as Amazon's \textit{Dynamo} database, column based stores such as \textit{Cassandra}, \textit{HBase} and document stores such as \textit{CouchDB}, \textit{Mongo}, etc. As \cite{GANESHCHANDRA201513} points out there are hundreds of NoSQL data stores and a comprehensive categorization of such products is not sensible. Although NoSQL databases are said to be \textit{schema-less}, \cite{ATZENI2016} points out that this is not the case: instead NoSQL databases allow for inconsistent schema representation across different entity instances due to the nature of how entities are aggregated. Such flexibility is at the heart of document stores such as CouchDB and Mongo where loose-schema modeling is one of the properties that makes such technologies suitable for large systems that generate data from inconsistent sources (i.e. a constant 'survey' entity with each type of survey having different questions).

CouchDB data models need to be represented by JSON structure. This is fairly straightforward for entities that can be easily thought of as 'objects'. JSON allows for nesting 'child' entities as sub-objects as an alternative to foreign key references in relational tables. As such, data is typically grouped differently in JSON documents compared to relational tables: JSON encourages groupings of specific entities, while relational tables encourage grouping entity types. Because JSON is far less structured than relational tables, entities of the same type may be represented differently - i.e. to think of entities as 'rows' of a relational table, each entity is allowed it's own variety of 'columns' in a JSON store. In a relational database this would result in a sparse table where every row has to include the columns of every other row of the same entity type. Such a case would result in massive amounts of wasted storage and inefficient indexing. But because CouchDB does not provide a means of differentiating between documents except by the content of each document, database content is not immediately classifiable by relations, fields, constraints and other objects that can be used to ascertain content type as can be done in RDBMSs; even MongoDB, an alternative JSON store to CouchDB uses the idea of 'collections' that allow for categorizing different types of documents. Since such categorizations in CouchDB are entirely logical, a document is unclassifiable except by retrieving and reading the entire document.