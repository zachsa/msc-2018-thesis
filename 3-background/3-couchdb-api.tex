\subsection{API}
\subsubsection{HTTP Interface}
All communication with CouchDB takes place via the HTTP protocol. The interface is resource orientated, and strives to be RESTful. This makes such interactions very clear since the HTTP endpoints that a user makes use of are logical and easy to remember - especially compared to clients used for interacting with relational databases. For example, the following endpoints (among many) are shown here, with the full API very well documented online at \cite{couch-api}.

\begin{enumerate}
    \item \textit{GET} /dbName/:id (retrieves a document with the specified ID)
    \item \textit{PUT} /dbName/[:id] (inserts a document, optionally specifying an ID)
    \item \textit{POST} /\_bulk\_docs (inserts multiple documents - atomicity of batch insert is configurable but defaults to false)
    \item \textit{POST/GET} /\_all\_docs (Fetches multiple documents, specifying keys can be done in in the body of a post request)
\end{enumerate}

\subsubsection{Design Documents}
CouchDB allows a user to specify several different types of functions that are executed on the server-side Erlang application via JSON - i.e. a regular database document but with an ID of ``\_design/documentName''. Such documents are known as ``Design'' documents and are treated as special by the CouchDB application. A sample design document is included in the appendix (see \ref{couchdb-design-doc-sample}), showing the format in which JavaScript functions are included in CouchDB JSON documents (other languages other than JavaScript can be specified as well). There are 6 types of functions that are executed on the server:

\begin{enumerate}
    \item \textit{views}
    \item \textit{shows}
    \item \textit{lists}
    \item \textit{updates}
    \item \textit{filters}
    \item \textit{validations}
\end{enumerate}

Views comprise two components - a \textit{Map}-function component and a \textit{Reduce}-function component, the contracts of which are shown in the appendix (see \ref{couchdb-mapreduce-contracts}). Map functions process documents to output a key:value as specified by the map function, and then reduce functions further process the results of the map function to create reduced output.

Show functions act as a type of 'middleware', by allowing users to specify transformations on a single document requested from the database and returning that document to the user - for example, transforming a document from JSON representation to HTML representation for better display in a browser. List functions, similarly to Show functions, allow for transforming documents retrieved from CoucDB and presenting a different representation of those documents to the user, but work on sets of documents instead of single documents. For example, list functions can retrieve results from a view index. As mentioned in \ref{slack-2-nov}, list functions are deprecated and should be replaced by code external to the CouchDB application. This would not be very challenging, and software such as the bespoke ETL tool written for this project (\textit{nETL}) could be easily configured to replace list functions with a small amount of coding. But since \textit{List} functions are likely to enjoy several more years of support in the CouchDB current release and possibly in the future, they are still a useful tool and are relevant enough that their use is not unwarranted in this project.

Other server functions are not used in this project, and so are discussed only briefly. Updates allow for specifying document updates indirectly via the HTTP API (functionally equivalent to retrieving a document, updating it and then reinserting it). Filters, true to their name, allow users to specify filters that can be used during view retrieval, document retrieval and in replicating data between CouchDB databases. Validations allow users to specify rules on when databases contained documents can be updated and by whom.

\subsection{Views: Indexes via MapReduce}
CouchDB doesn't actually provide a means of data-querying. Instead it allows for processing documents in a database file via MapReduce to produce \textit{Views}. These files are separate from database file and are structured as b+trees (as is the database file). In other words, CouchDB allows users to create b+tree indexes via MapReduce, and then to retrieve (view) projections, selection, aggregations, etc. of the documents in the database from these views via the HTTP interface. In a sense, CouchDB provides users a simple-to-use interface that allows for fine-grained control over b+tree structures.

\textit{Map} functions must be specified by a user and are always executed external to the main Erlang process via marshalling between the main Erlang process and the indexing engine. \textit{Reduce} functions, however, can either by executed via the main Erlang process (by specifying a built-in reduce function) or externally by the indexing engine when specifying custom reduce functions. CouchDB ships with an executable "couchjs.exe" - a JavaScript query-server (indexing engine) - coupled with Mozilla's \textit{SpiderMonkey} runtime engine. This query engine is drop-in replaceable by alternative implementations in JavaScript or other languages if required (this has not been done for this project). Unlike a traditional implementation of MapReduce where \textit{Map} and \textit{reduce} tasks are executed in parallel, CouchDB spawns a single \textit{couchjs} process per shard (see \ref{slack-1-nov} and \ref{slack-7-nov}) and the map index is calculated sequentially according to the order in which the database was changed.

Conceptually \textit{``fetching all documents of type x''} requires specifying an iteration through every document in the database and fetching documents that's content is indicative of \textit{``type x''}. View indices are built in CouchDB in this fashion; via iterating over every document in the database, and passing that document to the user-defined map function. A user writes code in this map function to evaluate each document, and emit key:value pairs depending on the content of the document. The map output is then grouped by key and passed to the reduce function for reduction.

Users can specify whether to retrieve reduced results, or to access unreduced map results (so a reduce function isn't actually required to produce a CouchDB view). However, when passing output from the map function to reducer, where map output is grouped by key, there is no guarantee that all map output for a particular key will be sent to the same reduce function \cite{reduceFunctions}. As such, a reduce function may operate on the same same output of the map function more than once; necessitating `rereduction' of reduced output. The reduce function requires handling of the case when rereduce = true, and when rereduce = false within the same function body. As such, writing custom reduce functions that adhere to the reduce function contract is fairly difficult for anything but the simplest examples. The reduce function is described here, with an implementation of the \textit{\_count} reduce function honoring this contract included in the appendix (see \ref{couchdb-mapreduce-contracts}) as an example and reference.

\begin{enumerate}
    \item \textit{keys}: a list of tuples of the form \textless \textit{key}, \textit{id} \textgreater. \textit{key} is the key emitted by the map function defined by the user, and \textit{id} is the id of the document that was processed by the map function to emit the key (this is implicit and not defined by a user). This argument is null in the case of rereduce = true.
    \item \textit{values}: a list of the values emitted by the map function as defined by the user, with each value correlating to a the respective element in the \textit{keys} list (when rereduce = false). When rereduce = true, this argument is a list of values previously output by this same reduce function on a previous execution.
    \item \textit{rereduce}: a boolean field indicating whether the function is invoked with output from the map function (rereduce = false), or previous output from this reduce function (rereduce = true). Reduce function results are cached on internal nodes in the B+tree view indexes to facilitate incremental tree updates without having to recalculate all reduce output (see appendix \ref{slack-25-oct}), making the rereduce contract necessary.
\end{enumerate}

Because of the nature of the \textit{reduce} function contract (allowing for rereduce = true), joins via MapReduce as described by \cite{chandar2010} are simply not possible. A SQL query of the form: \textit{R(a,b)} joined with \textit{S(b,c)} joined with \textit{T(c,d)} (where \textit{R}, \textit{S} and \textit{T} are relations and \textit{a}, \textit{b}, \textit{c}, \textit{d} are attributes) cannot be achieved without prior processing of all or some of the relations, or in the spirit of CouchDB, via multiple interactions with a view.

Although conceptually it's possible to produce composite return structures via CouchDB's Map and Reduce functions, as mentioned in \cite{reduceFunctions}, this is a misuse of CouchDB's query engine. Reduce functions in CouchDB views are specifically optimized to allow incremental index alterations (i.e. incrementally altering the view index in response to a document added to the database) \cite{reduceFunctions}. This is achieved by storing reduce output on leaves of the b+tree (view) nodes (see appendix \ref{slack-25-oct}), allowing for reduce results to be re-reduced further up the tree. This is unlike other implementations of MapReduce, for example for Hadoop, where MapReduce tasks may comprise 'pipelines' of multiple map and reduce phases (contracts of these functions are defined by users), where composite return structures are acceptable output for map and reduce functions since the output of such MapReduce tasks is not in itself an index.

\subsubsection{The \textit{\_stats} Reduce Function}
In terms of the contract of reduce functions, and expanding on the \_stats function (since this function is used extensively in this project), the \textit{\_stats} function signature requires that map output adhere to the following constraints: that values are either a single number or a list of numbers, that values (if lists) should be of the same length, and that indexes in value-lists each correlate with each other. Output of the map function is then grouped per key, and reduction involves aggregating values at corresponding indexes. Figure \ref{stats-reduce-fn} describes the contract of the \textit{\_stats} reduce function via representing how data is structured during index calculation at the mapping stage (A), the grouping stage (B), the signature with which the reduce function is called for this particular example (C), how the \textit{\_stats} function is applied to the grouped values (D), and the output of the \textit{\_stats} function (E).

Output of the \textit{\_stats} function includes a count of how many items are included in the aggregation, the minimum value, the maximum value, the sum of all the values, and the sum of squares of all the values. This information overlaps with the output produced by the \textit{\_sum} and \textit{\_count} built-in reduce functions.

\begin{figure}[H]
    \begin{minted}{javascript}
// A
{["key"]: [1,1,0]} // (_id: x)
{["key"]: [3,1,3]} // (_id: y)
{["key2"]: [2,2,2]} // (_id: z)

// B
{["key"]: [[1,1,0],[3,1,3]]}
{["ke2"]: [[2,2,2]]}

// C
reduce([["key", "x"], ["key", "y"]], [[1,1,0],[3,1,3]], false)
reduce([["key2", "z"]], [[2,2,2]], false)

// D
{["key"]: [aggregate([1,3]), aggregate([1,1]),  aggregate([0,3])]}
{["key2"]: [aggregate([2]), aggregate([2]),  aggregate([2])]}

// E
{
  ["key"]: [
    {"sum":4,"count":2,"min":1,"max":3,"sumsqr":10},
    {"sum":2,"count":2,"min":1,"max":1,"sumsqr":2},
    {"sum":3,"count":2,"min":0,"max":3,"sumsqr":9}
  ],
  ["key2"]: [
    {"sum":2,"count":1,"min":2,"max":2,"sumsqr":4}
  ]
}
    \end{minted}
    \caption[\textit{\_stats} function contract]{\textbf{Figure \ref{stats-reduce-fn}: Reduce function contract.} (A): Output of the map function. [``key''] is the key for which a value is emitted (in this case, they key is a compound key but with only one index). The value in this case is a tuple of [x, y, z]. (B): Results from the Map function are grouped by a common key, with values grouped into a list - in this case a list of lists since the value output of the map function is a list. (C): The signature with which the reduce function is called with corresponding arguments. (D): The \textit{\_stats} function then further groups values by corresponding indexes and aggregates these values. (E): The result of the \textit{\_stats} function aggregation.}
    \label{stats-reduce-fn}
\end{figure}