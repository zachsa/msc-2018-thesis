\section{CouchDB}

\subsection{Overview}
The CouchDB database is a 'document' based data-store, meaning that a CouchDB database comprises a series of JSON strings. A brief description of CouchDB's internals is discussed in online documentation \cite{couchguide}: JSON strings are appended to database files that are structured as B+ trees optimized for fast data retrieval from huge databases, that B+ tree implementation incorporates a MVCC (Multi-Version-Concurrency-Control) model, and that disc-writing is done via an 'append-only' approach. Aside from write operations being serialized, MVCC negates the needs for locks that are typically implemented within RDBMSs and are expensive in terms of computer resources. Without locking on read/write operations, CouchDB data stores are infinitely available with the caveat that such available documents may not always be the most recent versions of those documents. CouchDB represents a trade-off of \textit{consistency} for \textit{availability} to facilitate scalability in terms of handling large amounts of data in near-realtime. In this way CouchDB could be considered with reference to the \textit{BASE} model similarly to many other NoSQL databases. \textit{BASE} stands for \textit{Basically Available}, \textit{Soft State}, \textit{Eventual Consistency}. This is in contrast to \textit{ACID} guarantees that older RDMSs guarantee, although CouchDB does guarantee atomic (all or nothing) document writes. Research in 1999 by \cite{cap} introduced the idea of the \textit{CAP} theorem as a trade-off analysis of 3 properties of a data storage system\textit{Consistency}, \textit{Availability}, and \textit{Partition-tolerance} faced with the inevitability of network downtime. Despite populate opinion, all three properties ARE fully achievable without network downtime. From CouchDB 2.0 onwards users can configure the desired level of consistency of document reads, but not document writes.

CouchDB as a document store doesn't, in itself, provide a means of data-querying. Instead it allows for processing of database file(s) via MapReduce to produce separate files (\textit{Views}) that are derived from a single database. These derived sets of data are also structured as B+Trees, as are the initial database files. In other words, A CouchDB database may comprise B+ tree files for storage and separate B+ tree index files for querying. As pointed out in the documentation \cite{couchguide}, CouchDB is effectively a B+tree engine that provides users a means of interacting directly with B+trees via an HTTP API. Via this API a user is able to interact directly with the database B+tree, to which all view files are linked; changes to a database file results in incremental adjustment of the view file via the specified MapReduce functions. So in a sense you donâ€™t 'query' couch. You actually specify a MapReduce task to create a completely separate store of data. And then you can search the B+ tree view files by using the REST API.

\subsection{Entity Models}
Compared to relational models, CouchDB data models need to be represented by JSON structure. This is fairly straightforward for entities that can be easily thought of as 'objects'. JSON allows for nesting 'child' entities as sub-objects as an alternative to foreign key references in relational tables. As such, data is typically grouped differently in JSON documents compared to relational tables: JSON encourages groupings of specific entities, while relational tables encourage grouping entity types. Because JSON is far less structured than relational tables, entities of the same type may be represented differently - i.e. to think of entities as 'rows' of a relational table, each entity is allowed it's own variety of 'columns' in a JSON store. In a relational database this would result in a sparse table where every row has to include the columns of every other row of the same entity type. Such a case would result in massive amounts of wasted storage and inefficient indexing.