\subsection{API}
\subsubsection{Design documents}
CouchDB allows a user to specify several different types of functions that are executed on the server-side Erlang application. These functions need to be specified on a 'Design' document, which is simply a normal JSON document with an attribute ``\_id'' having a value of ``\_design/documentName''. There are 6 types of functions that a user can specify and are executed by the CouchDB application on the server: \textit{views}, \textit{shows}, \textit{lists}, \textit{updates}, \textit{filters}, and \textit{validation} checks. A full list of the server API can be seen in the sample design document in \ref{couchdb-design-doc-sample}.

Views comprise two components - a \textit{Map}-function component and a \textit{Reduce}-function component. The logic of these components can be specified by users as separate \textit{Map} and \textit{Reduce} functions - the contracts of which are shown in the appendix (see \ref{couchdb-mapreduce-contracts}). Such functions can be specified in a variety of languages including JavaScript and are executed via an engine external to the main CouchDB Erlang process. \textit{Map} functions must be specified by a user and are always executed external to the main Erlang process via marshalling between the main Erlang process and the view-calculating engine. \textit{Reduce} functions, however, can either by executed externally to the main Erlang process (as a custom reduce function) or within the main Erlang process via one of three built in functions: \_count, \_sum, and \_stats.

List functions fall under the category of \textit{CouchApps} and, as mentioned previously, are likely to be excluded from future releases. These functions iterate a view output to an HTTP(S) client, allowing a final phase of transformation - i.e. a data format switch from JSON documents to CSV format. These  functions take the name of a \textit{MapReduce} view as an argument and iterate through the results, passing those results to a user over HTTP(S). As with all of CouchDB interactions, list functions are invoked via HTTP and allow for an API of retrieving data from CouchDB views. As mentioned in \ref{slack-2-nov}, list functions are deprecated and should be replaced by code external to the CouchDB application. This would not be very challenging, and software such as the bespoke ETL tool written for this project (\textit{nETL}) could be easily configured to replace list functions with a small amount of coding. But since \textit{List} functions are likely to enjoy several more years of support in the CouchDB current release and possibly in the future, they are still a useful tool and are relevant enough that there use is not unwarranted in this project.

\subsubsection{Shows, Updates, Filters and Validation}
TODO:

\subsubsection{Inserting and retrieving documents}
TODO:


\subsubsection{HTTP endpoints}
TODO: \textit{\_bulk\_docs}



\subsection{View indices}
CouchDB as a document store doesn't, in itself, provide a means of data-querying. Instead it allows for processing of database file(s) via MapReduce to produce separate files (\textit{Views}) that are derived from a single database. These are separate files to the main database, and as are the database files, structured as b+trees. In other words, A CouchDB database comprises b+tree indexes for storage and separate b+tree indexes derived from the main database files. So in a sense you donâ€™t 'query' couch. You actually specify a MapReduce task to create a completely separate stores of data. And then you can search those b+trees via the HTTP API.

Worth mentioning in the context of couchDB specifically, is the MapReduce engine used. CouchDB ships with an executable "couchjs.exe" - the \textit{javaScript} query-server - coupled with Mozilla's \textit{SpiderMonkey} runtime engine; this query engine is drop-in replaceable, although there is probably no motivation to do so. Unlike a traditional implementation of MapReduce where \textit{Map} and \textit{reduce} tasks are executed in parallel, CouchDB spawns a single \textit{couchjs} process per shard (see \ref{slack-1-nov} and \ref{slack-7-nov}) and the map index is calculated sequentially according to the order in which the database was changed.

Conceptually \textit{``fetching all documents of type x''} requires specifying an iteration through every document in the database and fetching documents that's content is indicative of \textit{``type x''}. View indices are built in CouchDB in this fashion; via iterating over every document in the database, and passing that document to the user-defined map function. A user writes code in this map function to evaluate each document, and emit key:value pairs depending on the content of the document. The map output is then grouped by key and passed to the reduce function for reduction, the output of which is stored on internal nodes of the of the view index (see appendix \ref{slack-25-oct}). This allows for incremental update of reduce-function output as a result of incrementally updating the view index.

Users can specify whether to retrieve reduced results, or to access unreduced map results (so a reduce function isn't actually required to produce a CouchDB view). However, when passing output from the map function to reducer, where map output is gropued by key, there is no guanantee that all map output for a particular key will be sent to the same reduce function \cite{reduceFunctions}. As such, a reduce function may operate on the same same output of the map function more than once; necessitating `rereduction' of reduced output. The reduce function requires handling of the case when rereduce = true, and when rereduce = false within the same function body. As such, writing custom reduce functions that adhere to the reduce function contract is fairly difficult for anything but the simplest examples; a custom implementation of the \textit{\_count} reduce function is shown in the appendix (see \ref{couchdb-mapreduce-contracts}) as an example. A description of the reduce function contract is summarized here:

\begin{enumerate}
  \item \textit{keys}: a list of tuples of the form \textless \textit{key}, \textit{id} \textgreater. \textit{key} is the key emitted by the map function defined by the user, and \textit{id} is the id of the document that was processed by the map function to emit the key (this is implicit and not defined by a user). This argument is null in the case of rereduce = true.
  \item \textit{values}: a list of the values emitted by the map function as defined by the user, with each value correlating to a the respective element in the \textit{keys} list (when rereduce = false). When rereduce = true, this argument is a list of values previously output by this same reduce function on a previous execution.
  \item \textit{rereduce}: a boolean field indicating whether the function is invoked with output from the map function (rereduce = false), or previous output from this reduce function (rereduce = true). Reduce function results are cached on internal nodes in the B+tree view indexes to facilitate incremental tree updates without having to recalculate all reduce output (see appendix \ref{slack-25-oct}), making the rereduce contract necessary.
\end{enumerate}

Because of the nature of the \textit{reduce} function contract (allowing for rereduce = true), joins via MapReduce as described by \cite{chandar2010} are simply not possible. A SQL query of the form: \textit{R(a,b)} joined with \textit{S(b,c)} joined with \textit{T(c,d)} (where \textit{R}, \textit{S} and \textit{T} are relations and \textit{a}, \textit{b}, \textit{c}, \textit{d} are attributes) cannot be achieved without prior processing of all or some of the relations, or in the spirit of CouchDB, via multiple interactions with a view.

Although conceptually it's possible to produce composite return structures via CouchDB's Map and Reduce functions, as mentioned in in \cite{reduceFunctions}, this is a misuse of CouchDB's query engine. Reduce functions in CouchDB views are specifically optimized to allow incremental index alterations (i.e. incrementally altering the view index in response to a document added to the database) \cite{reduceFunctions}. As such, reduce functions in CouchDB are specifically aimed at aggregating output of Map functions.

This is unlike other implementations of MapReduce, for example for Hadoop, where MapReduce tasks may comprise 'pipelines' of multiple map and reduce phases (contracts of these functions are defined by users), where composite return structures are acceptable output for map and reduce functions, and where data storage structures are not optimized for specific results.

\subsubsection{The \textit{\_stats} function}
In terms of the contract of reduce functions, and expanding on the \_stats function (since this function is used extensively in this project), the \textit{\_stats} function signature requires that map output adhere to the following constraints: that values are either a single number or a list of numbers, that values (if lists) should be of the same length, and that indexes in value-lists each correlate with each other. Output of the map function is then grouped per key, and reduction involves aggregating values at corresponding indexes. Figure \ref{stats-reduce-fn} describes the contract of the \textit{\_stats} reduce function via representing how data is structured during index calculation at the mapping stage (A), the grouping stage (B), the signature with which the reduce function is called for this particular example (C), how the \textit{\_stats} function is applied to the grouped values (D), and the output of the \textit{\_stats} function (E).

Output of the \textit{\_stats} function includes a count of how many items are included in the aggregation, the minimum value, the maximum value, the sum of all the values, and the sum of squares of all the values. This information overlaps with the output produced by the \textit{\_sum} and \textit{\_count} built-in reduce functions.

\begin{figure}[H]
  \begin{minted}{javascript}
// A
{["key"]: [1,1,0]} // (_id: x)
{["key"]: [3,1,3]} // (_id: y)
{["key2"]: [2,2,2]} // (_id: z)

// B
{["key"]: [[1,1,0],[3,1,3]]}
{["ke2"]: [[2,2,2]]}

// C
reduce([["key", "x"], ["key", "y"]], [[1,1,0],[3,1,3]], false)
reduce([["key2", "z"]], [[2,2,2]], false)

// D
{["key"]: [aggregate([1,3]), aggregate([1,1]),  aggregate([0,3])]}
{["key2"]: [aggregate([2]), aggregate([2]),  aggregate([2])]}

// E
{
  ["key"]: [
    {"sum":4,"count":2,"min":1,"max":3,"sumsqr":10},
    {"sum":2,"count":2,"min":1,"max":1,"sumsqr":2},
    {"sum":3,"count":2,"min":0,"max":3,"sumsqr":9}
  ],
  ["key2"]: [
    {"sum":2,"count":1,"min":2,"max":2,"sumsqr":4}
  ]
}
    \end{minted}
  \caption[\textit{\_stats} function contract]{\textbf{Figure \ref{stats-reduce-fn}: Reduce function contract.} (A): Output of the map function. [``key''] is the key for which a value is emitted (in this case, they key is a compound key but with only one index). The value in this case is a tuple of [x, y, z]. (B): Results from the Map function are grouped by a common key, with values grouped into a list - in this case a list of lists since the value output of the map function is a list. (C): The signature with which the reduce function is called with corresponding arguments. (D): The \textit{\_stats} function then further groups values by corresponding indexes and aggregates these values. (E): The result of the \textit{\_stats} function aggregation.}
  \label{stats-reduce-fn}
\end{figure}