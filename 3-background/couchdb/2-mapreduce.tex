\subsection{MapReduce}
\subsubsection{Implementation}
Unlike in the traditional sense of 'MapReduce', Couch's reduce engine allows for partial groupings of a key via specifying the concept of 'rereduction' in the contract of the reduce function. More accurately, \textit{map} results are stored as B+ indexes within CouchDB including \textit{reduce} results cached on internal nodes (\cite{reduceFunctions} and see appendix \ref{slack-25-oct}) of these indexes. This allows for reduce output of nodes to be re-used and allows for incremental index updates.

As mentioned on the original CouchDB Wiki (no longer maintained, and is being migrated), \textit{map} output is sent the \textit{Reducer} in batches delimited by B+tree boundaries \cite{couchwiki}. Since grouping is done after this step by the \textit{Reducer}, reduce functions must allow for the case that not all values for a key are processed at once or by the same \textit{reduce} function. This allows for dispersed, partial and autonomous view calculation on any CouchDB node.

In terms of how MapReduce is executed in CouchDB, and possibly related to B+tree storage structures as mentioned above, grouping and reducing in CouchDB is handled by a 'master' node for any particular shard. Unlike a traditional implementation of MapReduce where \textit{Map} and \textit{reduce} tasks are executed in parallel, CouchDB spawns a single \textit{couchjs} process per shard (see \ref{slack-1-nov} and \ref{slack-7-nov}) and the map index is calculated sequentially according to a list of database changes as managed by CouchDB (available at the \textit{\_changes} endpoint).

Worth mentioning in the context of couchDB specifically, is the MapReduce engine used. CouchDB ships with an executable "couchjs.exe" - the \textit{javaScript} query-server - coupled with Mozilla's \textit{SpiderMonkey} runtime engine; this query engine is drop-in replaceable, although there is probably no motivation to do so. According to the documentation \cite{builtincouchreduce}, CouchDB has with a couple built-in reduce function - \_sum, \_count, and \_stats that are implemented as functions within the main Erlang process (as distinct from the mapping and reduction being handled by the main process) that perform substantially better than custom reduce functions since custom functions are not optimized and need to be executed externally to main process. This results in an I\/O overheard that is particularly severe on Windows machines (see \ref{slack-1-nov}).

Because of the nature of the \textit{reduce} function contract (allowing for rereduce = true), joins via MapReduce as described by \cite{chandar2010} are simply not possible. A SQL query of the form: \textit{R(a,b)} joined with \textit{S(b,c)} joined with \textit{T(c,d)} (where \textit{R}, \textit{S} and \textit{T} are relations and \textit{a}, \textit{b}, \textit{c}, \textit{d} are attributes) and expressed by the code (SQL Server syntax) below cannot be achieved without prior processing of all or some of the relations, or in the spirit of CouchDB, via multiple interactions with a view.

\begin{minted}{sql}
SELECT
[R].[a],
[T].[d]
FROM [R]
LEFT JOIN [S] on [S].[b] = [R].[b]
LEFT JOIN [T] ON [T].[c] = [S].[c]
\end{minted}

Although conceptually it's possible to produce composite return structures via CouchDB's Map and Reduce functions, as mentioned in in \cite{reduceFunctions}, this is a misuse of CouchDB's query engine. Reduce functions in CouchDB views are specifically optimized to allow incremental index alterations (i.e. incrementally altering the view index in response to a document added to the database) \cite{reduceFunctions}. As such, reduce functions in CouchDB are specifically aimed at aggregating output of Map functions.

This is unlike other implementations of MapReduce, for example for Hadoop, where MapReduce tasks may comprise 'pipelines' of multiple map and reduce phases (contracts of these functions are defined by users), where composite return structures are acceptable output for map and reduce functions, and where data storage structures are not optimized for specific results.

\subsubsection{The Reduce Function Contract}
It makes sense to define precisely what the contract for reduce functions is at this point. All CouchDB reduce functions accept three arguments as summarized in \cite{reduceFunctions}. These are:

\begin{enumerate}
    \item \textit{keys}: a list of tuples of the form \textless \textit{key}, \textit{id} \textgreater. \textit{key} is the key emitted by the map function defined by the user, and \textit{id} is the id of the document that was processed by the map function to emit the key (this is implicit and not defined by a user). This argument is null in the case of rereduce = true.
    \item \textit{values}: a list of the values emitted by the map function as defined by the user, with each value correlating to a the respective element in the \textit{keys} list (when rereduce = false). When rereduce = true, this argument is a list of values previously output by this same reduce function on a previous execution.
    \item \textit{rereduce}: a boolean field indicating whether the function is invoked with output from the map function (rereduce = false), or previous output from this reduce function (rereduce = true). Reduce function results are cached on internal nodes in the B+tree view indexes to facilitate incremental tree updates without having to recalculate all reduce output (see appendix \ref{slack-25-oct}), making the rereduce contract necessary.
\end{enumerate}

The reduce function requires handling of the case when rereduce = true, and when rereduce = false within the same function. As such, writing custom reduce functions that adhere to the reduce function contract is fairly difficult for anything but the simplest examples; a custom implementation of the \textit{\_count} reduce function is shown in the appendix (see \ref{couchdb-mapreduce-contracts}) as an example.