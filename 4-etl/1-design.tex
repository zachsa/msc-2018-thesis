\section{Design}
Conceptualizing a single ETL process as an entity of type \textit{Task}, that is, the ``extraction, transformation and loading of data from a source to destination'', provides a focal point on which the nETL software can be architected. Handling of instances of type \textit{Task} is done by an entity of type \textit{TaskManager}, which for the purposes of nETL v0.1 is implemented as a singleton (many instances of \textit{TaskManager} could potentially be useful if scaling of nETL were required). Objects of type \textit{Task} are instantiated via a \textit{Task} constructor, which takes a configuration object as an argument. This configuration is specified as a JSON file in which an operation of type \textit{Extraction}, operation(s) of type \textit{Transformation} and an operation of type \textit{Load} is described.

Starting the long-running nETL process comprises instantiating the singleton instance of type \textit{App}. This object holds references to the singleton instance of \textit{TaskManager} (taskManager), the E, T, and L operations and provides a CLI (command line interface) to facilitate user interactions. Via the CLI, users can interact with taskManager and load custom E, T, and L operations as well as start/stop tasks, configure application options such as log output path, etc. Via the CLI, the taskManager object is also able to provide user-feedback on the progress of tasks, messages from the E, T, and L operations, as well as display any program faults that may occur.

E, T, and L operations consist of JavaScript modules executable functions) that should adhere to their respective contracts; specifically, the contracts stipulate an object return on invocation of the module that creates closure over a variety of functions that can then be invoked by taskManager according to the required operation specified by the task object.

\input{4-etl/figures/fig-netl}

@sonia - this paragraph is new

Figure \ref{fig-nETL} shows the architecture for the nETL application - a configurable component-based ETL tool structured as a framework in which modules can be written for extraction, transformation and load \textit{tasks}. Module components are shown in the shaded boxes in the diagram and consist of two things: a configuration object specified in JSON format, and a JavaScript module that adheres to the specified contract format. References to tasks are created by module instantiation, which the contract stipulates should return an object with two properties: \mintinline{text}{name} and \mintinline{text}{exe}. The main \mintinline{text}{Application} singleton references the \mintinline{text}{exe} property of each module using the \mintinline{text}{name} value returned. the \mintinline{text}{exe} property references a function that is executed when a task specifies a particular module as part of the task's processing.

@sonia - this paragraph is new

On task-module execution, the function referenced via \mintinline{text}{exe} returns a function with a specified method name: \mintinline{text}{getNext()} for extractions, \mintinline{text}{transform(Object: obj)} for transformation, \mintinline{text}{batch(List: data)}. These methods are called in order during task execution - \mintinline{text}{getNext()} is called once per batch, \mintinline{text}{transform(obj)} is called once per item in each batch, and \mintinline{text}{load()} is called once per batch - until all data has been processed. The \mintinline{text}{Application} singleton controls reference-scoping during task execution, as well as providing an engine that serializes and controls task execution from start to finish. Part of this functionality includes error handling, logging, state persistence, and an API for user-process communication. Users can use the command line API to interact with \mintinline{text}{Application} to load task-modules, and with \mintinline{text}{taskManager} to load task-configurations. This architecture allows for separation of concerns; modules are self-contained and user-defined, as are the order in which these modules are executed (according to task configuration files). As such nETL allows for infinitely configurable data-flow processes.

\begin{itemize}
    \item It has a very succinct API making it fast to write code in (i.e. it is a highly abstracted language similarly to Ruby or Python)
    \item But unlike Ruby or Python (and other high level languages), it is opinionated in that it handles IO asynchronously by default
    \item The JavaScript implementation of object-orientation is appealing (to some developers at least \cite{jsBook})
    \item JavaScript is very much in line with the spirit of CouchDB
\end{itemize}